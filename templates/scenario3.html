<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escenario 03</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}" />
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        /* Contenedores de dise√±o principal */
        body {
            padding-top: 110px; /* Espacio para navegaci√≥n fija incluyendo men√∫ */
            font-size: 0.9rem;
        }
        #navigation {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: white;
            z-index: 1000;
            padding: 8px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Contenedor de secci√≥n de carga */
        #upload-section {
            background-color: white;
            padding: 20px;
            margin: 10px auto;
            max-width: 1400px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #e0e0e0;
        }
        #upload-section h2 {
            color: #343a40;
            font-size: 1.2rem;
            margin-bottom: 8px;
            text-align: center;
            font-weight: 500;
        }
        #controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
        #controls h1 {
            font-size: 0.9rem;
            margin: 0;
            color: #495057;
            font-weight: 500;
        }
        
        /* Contenedor de secci√≥n de mapa */
        #map-section {
            padding: 0;
            margin-top: 0;
        }
        #map-container {
            height: 50vh;
            width: 100%;
            max-width: 1400px;
            min-height: 380px;
            margin: 0 auto;
            position: relative;
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            transition: border-color 0.3s ease;
            background-color: white;
        }
        
        /* Ajustes responsivos */
        @media (max-width: 768px) {
            body {
                padding-top: 90px; /* M√°s espacio para navegaci√≥n m√≥vil */
            }
            #upload-section {
                margin: 5px;
                padding: 15px;
            }
            #map-section {
                padding: 20px 10px;
            }
            #map-container {
                height: 60vh;
                min-height: 400px;
                border-radius: 8px;
            }
            #controls {
                flex-direction: column;
                gap: 10px;
            }
        }
        
        #map-container.active {
            border-color: #007bff;
            box-shadow: 0 8px 25px rgba(0,123,255,0.3);
        }
        #zoom-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
            z-index: 1000;
            display: none;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        #topology-select {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ced4da;
            background-color: white;
            font-size: 0.95rem;
            min-width: 200px;
        }
        #topology-select:focus {
            border-color: #80bdff;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
            outline: none;
        }
        #upload-button {
            padding: 8px 16px;
            border-radius: 5px;
            border: 1px solid #007bff;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        #upload-button:hover {
            background-color: #0056b3;
            border-color: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,123,255,0.3);
        }
        #center-map-button {
            padding: 8px 16px;
            border-radius: 5px;
            border: 1px solid #28a745;
            background-color: #28a745;
            color: white;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        #center-map-button:hover {
            background-color: #218838;
            border-color: #218838;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(40,167,69,0.3);
        }
        
        /* Estilos del panel de par√°metros */
        #parameters-panel {
            position: fixed;
            right: -400px;
            top: 80px;
            width: 380px;
            height: calc(100vh - 100px);
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px 0 0 8px;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            transition: right 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }
        #parameters-panel.open {
            right: 0;
        }
        #parameters-panel .panel-header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #parameters-panel .panel-header h3 {
            margin: 0;
            font-size: 1.1rem;
            color: #343a40;
        }
        #parameters-panel .panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        .parameter-group {
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background: #f8f9fa;
        }
        .parameter-group-header {
            background: #007bff;
            color: white;
            padding: 8px 12px;
            font-weight: 500;
            font-size: 0.9rem;
            border-radius: 5px 5px 0 0;
        }
        .parameter-item {
            padding: 8px 12px;
            border-bottom: 1px solid #e9ecef;
            background: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .parameter-item:last-child {
            border-bottom: none;
            border-radius: 0 0 5px 5px;
        }
        .parameter-label {
            font-size: 0.85rem;
            color: #495057;
            font-weight: 500;
            flex: 1;
            cursor: help;
        }
        .parameter-value {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .parameter-input {
            width: 80px;
            padding: 4px 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 0.8rem;
            text-align: right;
        }
        .parameter-input:disabled {
            background-color: #f8f9fa;
            color: #6c757d;
        }
        .parameter-unit {
            font-size: 0.75rem;
            color: #6c757d;
            min-width: 35px;
        }
        .close-panel {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #6c757d;
        }
        .close-panel:hover {
            color: #343a40;
        }
        
        /* Estilos de tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 220px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1002;
            bottom: 125%;
            left: 50%;
            margin-left: -110px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem;
        }
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Estilos de secci√≥n de c√°lculo */
        #calculation-section {
            padding: 0 15px;
            max-width: 1400px;
            margin: 5px auto 5px auto; /* Further reduced margins */
            background-color: transparent;
            border-top: none;
        }
        .calculation-panel {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            border: 1px solid #e0e0e0;
            height: auto; /* Changed from 100% to auto to fit content */
            min-height: auto; /* Remove any minimum height constraints */
        }
        .panel-title {
            font-size: 1rem;
            color: #343a40;
            margin-bottom: 10px; /* Reduced from 12px to 10px */
            font-weight: 500;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px; /* Reduced from 6px to 5px */
        }
        .form-row-flex {
            display: flex;
            gap: 12px;
            margin-bottom: 6px; /* Reduced from 8px to 6px */
            align-items: flex-start;
        }
        .flex-grow {
            flex-grow: 1;
        }
        .align-self-flex-end {
            align-self: flex-end;
        }
        .sub-panel-title {
            font-size: 0.95rem;
            color: #6c757d;
            margin-top: 0;
            margin-bottom: 8px; /* Reduced from 10px to 8px */
            font-weight: 500;
        }
        .form-group {
            margin-bottom: 0.4rem; /* Reduced from 0.5rem to 0.4rem */
        }
        .form-group label {
            display: block;
            margin-bottom: .25rem;
            font-weight: 500;
            color: #495057;
            font-size: 0.85rem;
        }
        .form-control, .custom-select, .btn {
            padding: .275rem .65rem;
            font-size: 0.9rem;
            border-radius: .2rem;
        }
        .custom-select {
            height: calc(1.5em + .55rem + 2px);
        }
        #calculate-route-button {
            width: 100%;
            padding: 0.4rem 1rem;
            font-size: 0.9rem;
            font-weight: 500;
        }
        .radio-group {
            padding-top: 0.15rem; /* Reduced from 0.25rem to 0.15rem */
        }
        .form-check-label {
            font-weight: 400;
        }
        .form-check-inline {
            margin-right: 1.5rem; /* Increased spacing for multi-line labels */
        }
        .form-check-inline .form-check-label {
            line-height: 1.2;
            vertical-align: top;
            margin-left: 0.5rem;
        }
        .form-check-inline .form-check-input {
            margin-top: 0.15rem; /* Align with first line of multi-line label */
        }

        /* Estilos de InfoWindow personalizado */
        .custom-infowindow {
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 0;
            max-width: 350px; /* Ancho aumentado para par√°metros EDFA */
            min-width: 280px; /* Ancho m√≠nimo */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px; /* Fuente ligeramente m√°s grande */
            color: #333;
        }
        .custom-infowindow-header {
            font-size: 15px; /* Fuente m√°s peque√±a */
            font-weight: 600;
            color: #ffffff;
            margin: 0;
            padding: 8px 12px; /* Relleno reducido */
            background: #007bff;
            border-bottom: 1px solid #0069d9;
            border-radius: 8px 8px 0 0;
        }
        .custom-infowindow-content {
            padding: 12px; /* Relleno reducido */
        }
        .custom-infowindow-content p {
            margin: 0 0 6px 0;
            line-height: 1.5;
        }
        .custom-infowindow-content strong {
            font-weight: 600;
            color: #555;
            min-width: 80px;
            display: inline-block;
        }
        .custom-infowindow-content .param-group {
            margin-top: 5px;
            padding-left: 15px;
            border-left: 3px solid #007bff;
        }
        .custom-infowindow-content .param-group p {
            font-family: monospace;
            font-size: 13px;
            margin-bottom: 3px;
        }
        .role-source {
            color: #28a745;
            font-weight: 700;
        }
        .role-destination {
            color: #007bff;
            font-weight: 700;
        }

        /* ----- Personalizaci√≥n de InfoWindow de Google Maps ----- */
        /* Oculta la burbuja blanca y sombra por defecto */
        .gm-style .gm-style-iw-c {
            padding: 0 !important;
            background-color: transparent !important;
            box-shadow: none !important;
        }
        .gm-style .gm-style-iw-d {
           overflow: hidden !important; /* Oculta barras de desplazamiento */
        }
        /* Oculta el bot√≥n de cerrar por defecto */
        .gm-style .gm-style-iw-t button {
            display: none !important;
        }
        /* Oculta la flecha por defecto */
        .gm-style .gm-style-iw-t::after {
            display: none;
        }

        #navigation .h1, #navigation h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem !important;
        }
        #navigation .btn-group .btn {
            padding: .25rem .75rem;
            font-size: .875rem;
        }
        #navigation .scenario-nav {
            margin-bottom: 0 !important; /* Prevent extra space pushing content up */
        }

        /* Asegura que el mapa coincida con la altura del panel derecho */
        .col-lg-8, .col-lg-4, #map-section {
            height: 100%;
        }
        #map-container, #map {
            height: 100%;
        }

        /* Estilos para la secci√≥n de resultados */
        #route-results {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .route-result {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        .route-result:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
        }

        .table-hover tbody tr:hover {
            background-color: rgba(0,123,255,0.1);
        }

        .badge {
            font-size: 0.8em;
        }

        .fs-6 {
            font-size: 1.1rem !important;
        }

        .card-header {
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }

        .alert-light {
            border-left: 4px solid #007bff;
        }

        .text-monospace {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .font-monospace {
            font-family: 'Courier New', monospace;
        }

        /* Mejoras para responsive design */
        @media (max-width: 768px) {
            .d-flex.justify-content-between {
                flex-direction: column;
                gap: 1rem;
            }
            
            .route-result .d-flex.justify-content-between .btn {
                width: 100%;
            }
        }

        /* Professional Modal Styles */
        .custom-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(3px);
            animation: fadeIn 0.3s ease-in-out;
        }

        .custom-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .custom-modal-content {
            background-color: #fefefe;
            margin: auto;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            animation: slideInDown 0.3s ease-out;
            position: relative;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .custom-modal-header {
            padding: 20px 24px 16px 24px;
            border-bottom: 1px solid #e9ecef;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .custom-modal-header.error {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
            border-bottom: none;
        }

        .custom-modal-header.warning {
            background: linear-gradient(135deg, #ffc107, #e0a800);
            color: #212529;
            border-bottom: none;
        }

        .custom-modal-header.success {
            background: linear-gradient(135deg, #28a745, #218838);
            color: white;
            border-bottom: none;
        }

        .custom-modal-header.info {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border-bottom: none;
        }

        .custom-modal-title {
            margin: 0;
            font-size: 1.4rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .custom-modal-icon {
            font-size: 1.6rem;
            opacity: 0.9;
        }

        .custom-modal-close {
            background: none;
            border: none;
            font-size: 28px;
            font-weight: 700;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s ease;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: inherit;
        }

        .custom-modal-close:hover {
            opacity: 1;
            background-color: rgba(255, 255, 255, 0.2);
        }

        .custom-modal-body {
            padding: 24px;
            line-height: 1.6;
            color: #495057;
        }

        .custom-modal-body h5 {
            color: #343a40;
            margin-bottom: 16px;
            font-weight: 600;
        }

        .custom-modal-body p {
            margin-bottom: 12px;
        }

        .custom-modal-body ul {
            padding-left: 20px;
            margin-bottom: 16px;
        }

        .custom-modal-body li {
            margin-bottom: 8px;
        }

        .documentation-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #007bff;
            text-decoration: none;
            font-weight: 500;
            padding: 10px 16px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            transition: all 0.2s ease;
            margin-top: 16px;
        }

        .documentation-link:hover {
            color: #0056b3;
            background-color: #e9ecef;
            border-color: #007bff;
            text-decoration: none;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
        }

        .documentation-link i {
            font-size: 1.1rem;
        }

        .custom-modal-footer {
            padding: 16px 24px 20px 24px;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .error-details {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 16px;
            margin-top: 16px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #495057;
        }
        
        .error-details pre {
            margin: 0;
            padding: 0;
            background: none;
            border: none;
            font-size: inherit;
            color: inherit;
        }

        .validation-errors {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 6px;
            padding: 16px;
            margin-top: 16px;
        }

        .validation-errors ul {
            margin-bottom: 0;
            color: #856404;
        }

        @media (max-width: 768px) {
            .custom-modal-content {
                width: 95%;
                margin: 10px;
            }
            
            .custom-modal-header, .custom-modal-body, .custom-modal-footer {
                padding-left: 16px;
                padding-right: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="navigation">
        <div class="container-fluid">
            <div class="row">
                <div class="col-12 text-center">
                    <h1 class="mb-3">Simulaci√≥n de topolog√≠as de red en google maps</h1>
                    {% include 'scenario_nav.html' %}
                </div>
            </div>
        </div>
    </div>
    <!-- Upload Section Container -->
    <div id="upload-section">
        <h2>Gesti√≥n de Topolog√≠as</h2>
        <div id="controls">
            <h1>Visualizaci√≥n de Topolog√≠a</h1>
            <select id="topology-select"></select>
            <input type="file" id="topology-upload" accept="application/json" style="display: none;" />
            <button id="upload-button">Subir Archivo</button>
            <button id="center-map-button" onclick="centerMapToNetwork()" title="Centrar mapa en la red">üìç Centrar Red</button>
        </div>
    </div>

    <!-- Main Content Section: Map and Simulation Parameters -->
    <div id="main-content-section" style="max-width: 1400px; margin: 5px auto; padding: 0 15px;">
        <div class="row">
            <!-- Map Column -->
            <div class="col-lg-8">
                <div id="map-section">
                    <div id="map-container">
                        <div id="zoom-hint">Click map to enable zoom, or hold Ctrl while scrolling</div>
                        <div id="map"></div>
                    </div>
                </div>
            </div>

            <!-- Simulation Parameters Column -->
            <div class="col-lg-4">
                <div class="calculation-panel" style="height: 100%;">
                    <h3 class="panel-title">Par√°metros de Simulaci√≥n</h3>
                    <div class="form-group">
                        <label for="f-min">f_min (THz)</label>
                        <input type="text" id="f-min" class="form-control" value="{{ si_config.f_min }}" placeholder="e.g., 191.3 or 191.3e12">
                    </div>
                    <div class="form-group">
                        <label for="baud-rate">baud_rate (Gbaud)</label>
                        <input type="text" id="baud-rate" class="form-control" value="{{ si_config.baud_rate }}" placeholder="e.g., 31.57 or 32e9">
                    </div>
                    <div class="form-group">
                        <label for="f-max">f_max (THz)</label>
                        <input type="text" id="f-max" class="form-control" value="{{ si_config.f_max }}" placeholder="e.g., 195.1 or 195.1e12">
                    </div>
                    <div class="form-group">
                        <label for="spacing">spacing (GHz)</label>
                        <input type="text" id="spacing" class="form-control" value="{{ si_config.spacing }}" placeholder="e.g., 50 or 50e9">
                    </div>
                    <div class="form-group">
                        <label for="power-dbm">power_dbm (dBm)</label>
                        <input type="number" id="power-dbm" class="form-control" value="{{ si_config.power_dbm }}" step="0.1">
                    </div>
                    <div class="form-group">
                        <label for="roll-off">roll_off</label>
                        <input type="number" id="roll-off" class="form-control" value="{{ si_config.roll_off }}" step="0.01">
                    </div>
                    <div class="form-group">
                        <label for="tx-osnr">tx_osnr (dB)</label>
                        <input type="number" id="tx-osnr" class="form-control" value="{{ si_config.tx_osnr }}" step="0.1">
                    </div>
                    <div class="form-group">
                        <label for="sys-margins">sys_margins (dB)</label>
                        <input type="number" id="sys-margins" class="form-control" value="{{ si_config.sys_margins }}" step="1">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Route Calculation Section -->
    <div id="calculation-section">
        <div class="calculation-panel">
            <h3 class="panel-title">C√°lculo de Ruta</h3>
            <h5 class="sub-panel-title">Selecci√≥n de Nodos</h5>
            <div class="form-row-flex">
                <div class="form-group flex-grow">
                    <label for="source-node">Nodo Origen</label>
                    <select id="source-node" class="form-control custom-select"></select>
                </div>
                <div class="form-group flex-grow">
                    <label for="destination-node">Nodo Destino</label>
                    <select id="destination-node" class="form-control custom-select"></select>
                </div>
            </div>
            <div class="form-row-flex">
                <div class="form-group flex-grow">
                    <label for="number-of-routes">Ingrese el n√∫mero de rutas optimas deseadas</label>
                    <input type="number" id="number-of-routes" class="form-control" 
                           min="1" max="10" step="1" 
                           placeholder="M√°ximo 10">
                </div>
            </div>
            <div class="form-row-flex">
                <div class="form-group">
                    <label>Criterio de Optimizaci√≥n</label>
                    <div class="radio-group">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="criteria" id="criteria-distance" value="distance" checked>
                            <label class="form-check-label" for="criteria-distance">
                                <strong>Distancia</strong>
                                <br><small class="text-muted">Prioriza rutas m√°s cortas</small>
                            </label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="criteria" id="criteria-osnr" value="osnr">
                            <label class="form-check-label" for="criteria-osnr">
                                <strong>OSNR</strong>
                                <br><small class="text-muted">Prioriza mejor calidad de se√±al</small>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="form-group align-self-flex-end">
                    <button id="calculate-route-button" class="btn btn-secondary" onclick="calculateRoutes()" disabled>Calcular Ruta</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Parameters Panel -->
    <div id="parameters-panel">
        <div class="panel-header">
            <h3>Network Parameters</h3>
            <button class="close-panel" onclick="closeParametersPanel()">&times;</button>
        </div>
        <div class="panel-body">
            <div id="parameters-content">
                <p style="color: #6c757d; text-align: center; padding: 20px;">
                    Click on a network element to view and modify its parameters
                </p>
            </div>
        </div>
    </div>

    <!-- Professional Modal Dialog -->
    <div id="customModal" class="custom-modal">
        <div class="custom-modal-content">
            <div id="modalHeader" class="custom-modal-header">
                <h4 id="modalTitle" class="custom-modal-title">
                    <span id="modalIcon" class="custom-modal-icon"></span>
                    <span id="modalTitleText"></span>
                </h4>
                <button id="modalClose" class="custom-modal-close" onclick="closeCustomModal()">&times;</button>
            </div>
            <div id="modalBody" class="custom-modal-body">
                <div id="modalMessage"></div>
            </div>
            <div id="modalFooter" class="custom-modal-footer">
                <button class="btn btn-secondary" onclick="closeCustomModal()">Cerrar</button>
            </div>
        </div>
    </div>

    <script>
        let map;
        let markers = {};
        let infoWindows = {};
        let polylines = [];

        // Professional Modal Dialog Functions
        function showCustomModal(title, message, type = 'info', documentationUrl = null, additionalData = null) {
            const modal = document.getElementById('customModal');
            const header = document.getElementById('modalHeader');
            const titleText = document.getElementById('modalTitleText');
            const icon = document.getElementById('modalIcon');
            const body = document.getElementById('modalMessage');
            
            // Set title
            titleText.textContent = title;
            
            // Set type-specific styling and icon
            header.className = `custom-modal-header ${type}`;
            
            switch (type) {
                case 'error':
                    icon.innerHTML = '‚ö†Ô∏è';
                    break;
                case 'warning':
                    icon.innerHTML = '‚ö†Ô∏è';
                    break;
                case 'success':
                    icon.innerHTML = '‚úÖ';
                    break;
                case 'info':
                default:
                    icon.innerHTML = '‚ÑπÔ∏è';
                    break;
            }
            
            // Build message content
            let messageContent = `<p>${message}</p>`;
            
            // Add validation errors if provided
            if (additionalData && additionalData.validation_errors && additionalData.validation_errors.length > 0) {
                messageContent += `
                    <div class="validation-errors">
                        <h5>Problemas identificados:</h5>
                        <ul>
                            ${additionalData.validation_errors.map(error => `<li>${error}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }
            
            // Add technical details if provided
            if (additionalData && additionalData.details) {
                messageContent += `
                    <div class="error-details">
                        <h5>Detalles t√©cnicos:</h5>
                        <pre style="white-space: pre-wrap; word-wrap: break-word; max-height: 200px; overflow-y: auto;">${additionalData.details}</pre>
                    </div>
                `;
            }
            
            // Add console messages if provided
            if (additionalData && additionalData.console_messages && additionalData.console_messages.length > 0) {
                messageContent += `
                    <div class="error-details">
                        <h5>Mensajes de consola:</h5>
                        <pre style="white-space: pre-wrap; word-wrap: break-word; max-height: 300px; overflow-y: auto;">${additionalData.console_messages.join('\n\n')}</pre>
                    </div>
                `;
            }
            
            // Add documentation link if provided
            if (documentationUrl) {
                messageContent += `
                    <div style="text-align: center; margin-top: 20px;">
                        <a href="${documentationUrl}" target="_blank" class="documentation-link" onclick="window.open('${documentationUrl}', '_blank');">
                            <i class="fas fa-external-link-alt"></i>
                            Ver Documentaci√≥n de Requisitos
                        </a>
                    </div>
                `;
            }
            
            body.innerHTML = messageContent;
            
            // Update footer with documentation button if URL is provided
            const footer = document.getElementById('modalFooter');
            if (documentationUrl) {
                footer.innerHTML = `
                    <button class="btn btn-primary" onclick="window.open('${documentationUrl}', '_blank');">
                        <i class="fas fa-external-link-alt"></i> Ver Documentaci√≥n
                    </button>
                    <button class="btn btn-secondary" onclick="closeCustomModal()">Cerrar</button>
                `;
            } else {
                footer.innerHTML = `
                    <button class="btn btn-secondary" onclick="closeCustomModal()">Cerrar</button>
                `;
            }
            
            // Show modal
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function closeCustomModal() {
            const modal = document.getElementById('customModal');
            modal.classList.remove('show');
            document.body.style.overflow = '';
        }

        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('customModal');
            if (event.target === modal) {
                closeCustomModal();
            }
        }

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeCustomModal();
            }
        });
        let currentTopologyData = null;
        let currentNodesMap = {}; // Store current nodes for map centering
        let defaultNodeIcon;
        
        // Funci√≥n global para cerrar todas las ventanas de informaci√≥n y prevenir superposici√≥n
        function closeAllInfoWindows() {
            Object.values(infoWindows).forEach(iw => iw.close());
        }
        
        // Inicializa el mapa
        function inicializarMapa() {
            defaultNodeIcon = {
                url: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png',
                scaledSize: new google.maps.Size(28, 28)
            };
            
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: -1.831239, lng: -78.183406 }, // Centro de Ecuador
                zoom: 7,
                scrollwheel: false, // Inicialmente deshabilitado
                gestureHandling: 'greedy' // Permite panor√°mica y zoom con controles t√°ctiles/rat√≥n
            });

            // Implementa control de zoom expl√≠cito basado en interacci√≥n
            const mapContainer = document.getElementById('map-container');
            const zoomHint = document.getElementById('zoom-hint');
            let mapIsActive = false;
            
            // Muestra pista al pasar el rat√≥n
            mapContainer.addEventListener('mouseenter', function() {
                if (!mapIsActive) {
                    zoomHint.style.display = 'block';
                }
            });
            
            mapContainer.addEventListener('mouseleave', function() {
                zoomHint.style.display = 'none';
                if (mapIsActive) {
                    mapIsActive = false;
                    mapContainer.classList.remove('active');
                    map.setOptions({ scrollwheel: false });
                }
            });
            
            // Habilita interacci√≥n del mapa cuando el usuario hace clic en el mapa
            mapContainer.addEventListener('mousedown', function() {
                mapIsActive = true;
                mapContainer.classList.add('active');
                zoomHint.style.display = 'none';
                map.setOptions({ scrollwheel: true });
            });
            
            // Deshabilita desplazamiento del mapa al hacer clic fuera del mapa
            document.addEventListener('click', function(e) {
                if (!mapContainer.contains(e.target)) {
                    mapIsActive = false;
                    mapContainer.classList.remove('active');
                    map.setOptions({ scrollwheel: false });
                }
            });
            
            // Maneja eventos de desplazamiento con control expl√≠cito
            mapContainer.addEventListener('wheel', function(e) {
                // Permite zoom del mapa solo si el mapa est√° activo O se mantiene presionada la tecla Ctrl
                if (mapIsActive || e.ctrlKey) {
                    map.setOptions({ scrollwheel: true });
                    e.preventDefault(); // Previene desplazamiento de p√°gina
                    e.stopPropagation();
                } else {
                    map.setOptions({ scrollwheel: false });
                    // Permite desplazamiento normal de p√°gina - no hace nada para dejar que el evento burbujee
                }
            }, { passive: false });

            // Carga los nombres de las topolog√≠as y llena el selector
            fetch('/get_topology_names')
                .then(response => response.json())
                .then(files => {
                    const select = document.getElementById('topology-select');
                    files.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file.replace('.json', '');
                        select.appendChild(option);
                    });

                    // Carga la topolog√≠a inicial
                    if (files.length > 0) {
                        cargarTopologia(files[0]);
                    }
                });

            // Agrega el detector de eventos de cambio al selector
            document.getElementById('topology-select').addEventListener('change', (e) => {
                cargarTopologia(e.target.value);
            });

            document.getElementById('source-node').addEventListener('change', () => {
                highlightSelectedNodes();
                validateCalculateButton();
            });
            document.getElementById('destination-node').addEventListener('change', () => {
                highlightSelectedNodes();
                validateCalculateButton();
            });
            document.getElementById('number-of-routes').addEventListener('input', () => {
                validateCalculateButton();
            });
            
            // Add event listeners for radio buttons
            document.querySelectorAll('input[name="criteria"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    validateCalculateButton();
                });
            });

            const uploadButton = document.getElementById('upload-button');
            const fileInput = document.getElementById('topology-upload');

            uploadButton.addEventListener('click', () => fileInput.click());

            fileInput.addEventListener('change', () => {
                const file = fileInput.files[0];
                if (!file) {
                    return;
                }

                const formData = new FormData();
                formData.append('file', file);

                fetch('/upload_topology', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.filename) {
                        // Check validation status and show appropriate message
                        if (data.validation && !data.validation.valid && data.validation.severity === 'critical') {
                            showCustomModal(
                                'Archivo Subido con Errores Cr√≠ticos',
                                `El archivo "${data.filename}" se subi√≥ correctamente, pero la topolog√≠a tiene problemas cr√≠ticos que impiden los c√°lculos.`,
                                'error',
                                data.validation.documentation_url,
                                {
                                    validation_errors: data.validation.errors || []
                                }
                            );
                        } else if (data.validation && data.validation.warnings) {
                            showCustomModal(
                                'Archivo Subido con Recomendaciones',
                                `El archivo "${data.filename}" se subi√≥ correctamente y permite c√°lculos, pero se recomienda revisar las mejores pr√°cticas.`,
                                'warning',
                                data.validation.documentation_url,
                                {
                                    validation_errors: data.validation.warnings || []
                                }
                            );
                        } else {
                            showCustomModal(
                                'Archivo Subido Exitosamente',
                                `El archivo "${data.filename}" se subi√≥ correctamente y cumple con todos los requisitos.`,
                                'success'
                            );
                        }
                        
                        // Actualiza la lista de topolog√≠as
                        fetch('/get_topology_names')
                            .then(response => response.json())
                            .then(files => {
                                const select = document.getElementById('topology-select');
                                select.innerHTML = ''; // Limpia las opciones existentes
                                files.forEach(f => {
                                    const option = document.createElement('option');
                                    option.value = f;
                                    option.textContent = f.replace('.json', '');
                                    select.appendChild(option);
                                });
                                
                                // Selecciona y carga la nueva topolog√≠a
                                select.value = data.filename;
                                cargarTopologia(data.filename);
                                fileInput.value = ''; // Reinicia el input del archivo
                            });
                    } else {
                        showCustomModal(
                            'Error al Subir Archivo',
                            'No se pudo subir el archivo al servidor.',
                            'error',
                            null,
                            {
                                details: data.error || 'Error desconocido'
                            }
                        );
                    }
                })
                .catch(error => {
                    console.error('Error al subir el archivo:', error);
                    showCustomModal(
                        'Error de Comunicaci√≥n',
                        'Ocurri√≥ un error durante la comunicaci√≥n con el servidor al intentar subir el archivo.',
                        'error',
                        null,
                        {
                            details: error.message || error.toString()
                        }
                    );
                });
            });
        }

        function cargarTopologia(filename) {
            fetch(`/get_topology?filename=${encodeURIComponent(filename)}`)
                .then(response => response.json())
                .then(data => {
                    currentTopologyData = data;
                    dibujarTopologiaEnMapa(data);
                    populateTransceiverDropdowns(data);
                })
                .catch(error => console.error('Error cargando la topolog√≠a:', error));
        }

        function populateTransceiverDropdowns(data) {
            const sourceSelect = document.getElementById('source-node');
            const destinationSelect = document.getElementById('destination-node');

            sourceSelect.innerHTML = '<option value="">Seleccione nodo origen</option>';
            destinationSelect.innerHTML = '<option value="">Seleccione nodo destino</option>';

            const transceivers = (data.elements || []).filter(el => el.type === 'Transceiver');

            if (transceivers.length === 0) {
                const option = '<option value="" disabled>No se encontraron transceivers</option>';
                sourceSelect.innerHTML = option;
                destinationSelect.innerHTML = option;
                validateCalculateButton();
                return;
            }

            transceivers.forEach(t => {
                const option = document.createElement('option');
                option.value = t.uid;
                option.textContent = t.uid;
                sourceSelect.appendChild(option.cloneNode(true));
                destinationSelect.appendChild(option);
            });
            
            // Validate button state after populating dropdowns
            validateCalculateButton();
        }

        function dibujarTopologiaEnMapa(data) {
            limpiarMapa();
            const nodesMap = procesarNodos(data);
            currentNodesMap = nodesMap; // Store for manual centering
            dibujarNodos(nodesMap);
            dibujarEnlaces(data, nodesMap);
            
            // Auto-fit map to show all network nodes
            fitMapToNetwork(nodesMap);
        }

        function procesarNodos(data) {
            const nodesMap = {};
            const elements = data.elements || [];
            
            elements.forEach(el => {
                // Omite elementos que no son nodos de red o no tienen ubicaci√≥n
                if (el.type === "Fiber" || el.type === "fibre") return;
                
                const nodeId = normalizarIdNodo(el.uid);
                const location = extraerUbicacion(el);
                
                console.log('Processing element:', el.uid, 'Type:', el.type, 'Location:', location);
                
                if (location && location.lat && location.lng) {
                    nodesMap[nodeId] = {
                        id: nodeId,
                        latitude: parseFloat(location.lat),
                        longitude: parseFloat(location.lng),
                        title: String(el.uid),
                        type: el.type,
                        city: location.city || el.metadata?.location?.city,
                        raw: el
                    };
                    console.log('Added node to map:', nodeId, 'Type:', el.type);
                }
            });
            console.log('Final nodesMap:', nodesMap);
            return nodesMap;
        }

        function extraerUbicacion(element) {
            if (element.metadata?.location) {
                return {
                    lat: element.metadata.location.latitude,
                    lng: element.metadata.location.longitude,
                    city: element.metadata.location.city
                };
            } else if (element.location) {
                return {
                    lat: element.location.latitude || element.location.lat,
                    lng: element.location.longitude || element.location.lng,
                    city: element.location.city
                };
            }
            return null;
        }

        /* Genera tooltip espec√≠fico para EDFA (usando l√≥gica de scenario02.py) */
        function crearTooltipEdfa(edfaElement) {
            console.log('Creating EDFA tooltip for element:', edfaElement);
            
            if (!edfaElement) {
                console.log('No EDFA element provided');
                return '';
            }
            
            const uid = edfaElement.uid || 'N/A';
            const type = edfaElement.type || 'Edfa';
            const typeVar = edfaElement.type_variety || 'N/A';
            
            console.log('EDFA basic info - UID:', uid, 'Type:', type, 'Type Variety:', typeVar);
            
            // gain_target desde operacional (topolog√≠a)
            let gainTarget = 'N/A';
            if (edfaElement.operational && edfaElement.operational.gain_target !== undefined) {
                gainTarget = edfaElement.operational.gain_target;
                console.log('Found gain_target in operational:', gainTarget);
            } else if (edfaElement.parameters && edfaElement.parameters.gain_target) {
                gainTarget = edfaElement.parameters.gain_target.value ?? edfaElement.parameters.gain_target;
                console.log('Found gain_target in parameters:', gainTarget);
            } else {
                console.log('No gain_target found. Operational:', edfaElement.operational, 'Parameters:', edfaElement.parameters);
            }

            // NF desde configuraci√≥n de equipos (como enfoque de scenario02.py)
            let nfVal = 'N/A';
            if (edfaElement.parameters && edfaElement.parameters.nf0 !== undefined) {
                nfVal = edfaElement.parameters.nf0.value ?? edfaElement.parameters.nf0;
                console.log('Found nf0 in element parameters:', nfVal);
            } else if (edfaElement.type_variety && currentTopologyData && currentTopologyData.eqpt_config) {
                // Busca en configuraci√≥n de equipos (misma l√≥gica que scenario02.py)
                const edfaConfigs = currentTopologyData.eqpt_config.Edfa || [];
                console.log('Looking for type_variety in equipment config:', edfaElement.type_variety, 'Available configs:', edfaConfigs);
                const cfg = edfaConfigs.find(c => c.type_variety === edfaElement.type_variety);
                if (cfg) {
                    nfVal = cfg.nf0 !== undefined ? cfg.nf0 : (cfg.nf_min !== undefined ? cfg.nf_min : 'N/A');
                    console.log('Found NF in equipment config:', nfVal, 'Config:', cfg);
                } else {
                    console.log('No matching equipment config found for type_variety:', edfaElement.type_variety);
                }
            } else {
                console.log('Cannot find NF - missing data. Type variety:', edfaElement.type_variety, 'Has topology data:', !!currentTopologyData, 'Has eqpt_config:', !!(currentTopologyData && currentTopologyData.eqpt_config));
            }

            const tooltipHTML = `
                <div class="custom-infowindow">
                    <h3 class="custom-infowindow-header">EDFA</h3>
                    <div class="custom-infowindow-content">
                        <p><strong>UID:</strong> ${uid}</p>
                        <p><strong>Type:</strong> ${type}</p>
                        <p><strong>Type Variety:</strong> ${typeVar}</p>
                        <p><strong>gain_target:</strong> ${gainTarget} dB</p>
                        <p><strong>NF:</strong> ${nfVal} dB</p>
                    </div>
                </div>`;
            
            console.log('Generated EDFA tooltip HTML:', tooltipHTML);
            return tooltipHTML;
        }

        function dibujarNodos(nodesMap) {
            Object.values(nodesMap).forEach(node => {
                // Elige icono basado en el tipo de elemento
                let iconMarker = defaultNodeIcon;
                if (node.raw && node.raw.type === 'Edfa') {
                    iconMarker = {
                        path: 'M -5,0 0,-8 5,0 0,8 Z',
                        scale: 1,
                        fillColor: '#FF4500',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#8B0000'
                    };
                }

                const marker = new google.maps.Marker({
                    position: { lat: node.latitude, lng: node.longitude },
                    map: map,
                    title: node.title,
                    icon: iconMarker
                });
                markers[node.id] = marker;

                // Genera contenido de tooltip (detecci√≥n EDFA ahora manejada dentro de crearContenidoInfoNodo)
                let tooltipContent = crearContenidoInfoNodo(node);
                
                console.log('Node:', node.id, 'Type:', node.type, 'Raw type:', node.raw?.type);
                
                const infoWindow = new google.maps.InfoWindow({
                    content: tooltipContent
                });
                infoWindows[node.id] = infoWindow;

                marker.addListener('mouseover', () => {
                    closeAllInfoWindows();
                    
                    const sourceId = document.getElementById('source-node').value;
                    const destinationId = document.getElementById('destination-node').value;
                    let role = null;
                    if (node.id === sourceId) role = "Nodo Origen";
                    if (node.id === destinationId) role = "Nodo Destino";
                    
                    const content = crearContenidoInfoNodo(node, role);
                    infoWindow.setContent(content);
                    infoWindow.open(map, marker);
                });

                marker.addListener('mouseout', () => {
                    infoWindow.close();
                });

                // Clic deshabilitado ‚Äì panel de par√°metros removido seg√∫n nuevos requerimientos
                marker.addListener("click", () => {});
            });
        }

        function dibujarEnlaces(data, nodesMap) {
            const elements = data.elements || [];
            const connections = data.connections || [];

            if (connections.length === 0) return;

            const elementsMap = new Map(elements.map(el => [normalizarIdNodo(el.uid), el]));
            const adj = new Map();

            connections.forEach(c => {
                const from = normalizarIdNodo(c.from_node);
                const to = normalizarIdNodo(c.to_node);
                if (!adj.has(from)) adj.set(from, new Set());
                if (!adj.has(to)) adj.set(to, new Set());
                adj.get(from).add(to);
                adj.get(to).add(from); // Tratar como no dirigido para encontrar el camino
            });

            const drawnLinks = new Set();

            for (const startNodeId of Object.keys(nodesMap)) {
                const q = [[startNodeId, [startNodeId]]];
                const visitedInSearch = new Set([startNodeId]);

                while (q.length > 0) {
                    const [currentNodeId, path] = q.shift();

                    if (!adj.has(currentNodeId)) continue;

                    for (const neighborId of adj.get(currentNodeId)) {
                        if (visitedInSearch.has(neighborId)) continue;
                        
                        if (nodesMap[neighborId]) { // Se encontr√≥ otro nodo con ubicaci√≥n
                            const linkKey = [startNodeId, neighborId].sort().join('->');
                            if (drawnLinks.has(linkKey)) continue;
                            
                            visitedInSearch.add(neighborId);
                            const newPath = [...path, neighborId];
                            
                            const startNode = nodesMap[startNodeId];
                            const endNode = nodesMap[neighborId];

                            let totalLength = 0;
                            let hasFiber = false;
                            let fiberElement = null;

                            for (const nodeId of newPath) {
                                const element = elementsMap.get(nodeId);
                                if (element && (element.type === 'Fiber' || element.type === 'fibre')) {
                                    hasFiber = true;
                                    fiberElement = element; // Store fiber element for tooltip
                                    if (element.params && element.params.length) {
                                        totalLength += element.params.length;
                                    }
                                }
                            }

                            dibujarConexion(startNode, endNode, { color: "#FF0000", weight: 3 }, fiberElement);
                            drawnLinks.add(linkKey);

                            // Removed automatic EDFA insertion along fibers
                        } else {
                            visitedInSearch.add(neighborId);
                            const newPath = [...path, neighborId];
                            q.push([neighborId, newPath]);
                        }
                    }
                }
            }
        }

        function dibujarConexion(startNode, endNode, style, fiberElement = null) {
            const path = [
                { lat: startNode.latitude, lng: startNode.longitude },
                { lat: endNode.latitude, lng: endNode.longitude }
            ];

            const line = new google.maps.Polyline({
                path: path,
                geodesic: true,
                strokeColor: style.color || "#FF0000",
                strokeOpacity: style.opacity || 1.0,
                strokeWeight: style.weight || 2,
                map: map,
                zIndex: 1 // Lower zIndex for topology connections
            });
            // Explicitly mark as topology connection (not route highlight)
            line.routeHighlight = false;
            polylines.push(line);

            const distance = haversine(
                startNode.latitude, startNode.longitude,
                endNode.latitude, endNode.longitude
            );

            const infoWindow = new google.maps.InfoWindow({
                content: crearContenidoInfoEnlace(style, startNode, endNode, distance, fiberElement)
            });

            line.addListener('mouseover', (event) => {
                closeAllInfoWindows();
                
                infoWindow.setPosition(event.latLng);
                infoWindow.open(map);
            });
            line.addListener('mouseout', () => {
                infoWindow.close();
            });
        }
        
        function limpiarMapa() {
            Object.values(markers).forEach(marker => marker.setMap(null));
            polylines.forEach(line => line.setMap(null));
            Object.values(infoWindows).forEach(iw => iw.close());
            markers = {};
            polylines = [];
            infoWindows = {};
            currentNodesMap = {}; // Clear stored nodes map
        }
        
        function obtenerPuntoMedio(p1, p2) {
            return {
                lat: (p1.lat + p2.lat) / 2,
                lng: (p1.lng + p2.lng) / 2
            };
        }

        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radio de la Tierra en km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            return 2 * R * Math.asin(Math.sqrt(a));
        }

        function crearContenidoInfoNodo(node, role = null) {
            // Check if this is an EDFA element
            const isEdfa = (node.raw && node.raw.type === 'Edfa') || node.type === 'Edfa';
            
            if (isEdfa) {
                // Use EDFA-specific tooltip
                return crearTooltipEdfa(node.raw || node);
            }
            
            // Default tooltip for non-EDFA elements
            let roleHtml = '';
            if (role) {
                const roleClass = role === 'Nodo Origen' ? 'role-source' : 'role-destination';
                roleHtml = `<p><strong>Rol:</strong> <span class="${roleClass}">${role}</span></p>`;
            }

            let content = `
                <div class="custom-infowindow">
                    <h3 class="custom-infowindow-header">${node.title}</h3>
                    <div class="custom-infowindow-content">
                        ${roleHtml}
                        <p><strong>Ciudad:</strong> ${node.city || 'N/A'}</p>
                        <p><strong>Tipo:</strong> ${node.type}</p>
                        <p><strong>Latitud:</strong> ${node.latitude.toFixed(4)}¬∞</p>
                        <p><strong>Longitud:</strong> ${node.longitude.toFixed(4)}¬∞</p>
                    </div>
                </div>`;
            return content;
        }

        function crearContenidoInfoEnlace(linkData, startNode, endNode, distance, fiberElement = null) {
            let fiberParamsHtml = '';
            
            // Add fiber parameters if available
            if (fiberElement && fiberElement.params) {
                const params = fiberElement.params;
                fiberParamsHtml = `
                    <hr style="margin: 8px 0;">
                    <p><strong>Par√°metros de Fibra:</strong></p>
                    <p><strong>loss_coef:</strong> ${params.loss_coef || 'N/A'} dB/km</p>
                    <p><strong>att_in:</strong> ${params.att_in || 'N/A'} dB</p>
                    <p><strong>con_in:</strong> ${params.con_in || 'N/A'} dB</p>
                    <p><strong>con_out:</strong> ${params.con_out || 'N/A'} dB</p>
                `;
            }
            
            return `
                <div class="custom-infowindow">
                    <h3 class="custom-infowindow-header">Enlace de Fibra</h3>
                    <div class="custom-infowindow-content">
                        <p><strong>Desde:</strong> ${startNode.title}</p>
                        <p><strong>Hasta:</strong> ${endNode.title}</p>
                        <p><strong>Distancia:</strong> ${distance.toFixed(2)} km</p>
                        ${fiberParamsHtml}
                    </div>
                </div>`;
        }

        function normalizarIdNodo(id) {
            return String(id).trim();
        }

        // Parameters Panel Functions
        function openParametersPanel() {
            document.getElementById('parameters-panel').classList.add('open');
        }

        function closeParametersPanel() {
            document.getElementById('parameters-panel').classList.remove('open');
        }

        function showElementParameters(element) {
            openParametersPanel();
            const parametersContent = document.getElementById('parameters-content');
            
            if (!element.parameters) {
                parametersContent.innerHTML = '<p style="color: #dc3545; text-align: center; padding: 20px;">No parameters available for this element</p>';
                return;
            }

            let html = `<div class="parameter-group">
                <div class="parameter-group-header">${element.type}: ${element.uid}</div>`;
            
            for (const [paramName, paramData] of Object.entries(element.parameters)) {
                const inputId = `param-${element.uid}-${paramName}`;
                const isEditable = paramData.editable;
                
                html += `<div class="parameter-item">
                    <div class="parameter-label tooltip">
                        ${paramName.replace(/_/g, ' ').toUpperCase()}
                        <span class="tooltiptext">${paramData.tooltip}</span>
                    </div>
                    <div class="parameter-value">
                        <input type="number" 
                               id="${inputId}" 
                               class="parameter-input" 
                               value="${paramData.value}" 
                               step="0.1" 
                               ${!isEditable ? 'disabled' : ''}
                               ${isEditable ? `onchange="updateParameter('${element.uid}', '${paramName}', this.value)"` : ''}>
                        <span class="parameter-unit">${paramData.unit}</span>
                    </div>
                </div>`;
            }
            
            html += '</div>';
            parametersContent.innerHTML = html;
        }

        function updateParameter(elementUid, parameterName, newValue) {
            const data = {
                element_uid: elementUid,
                parameter_name: parameterName,
                new_value: parseFloat(newValue)
            };

            fetch('/update_network_parameters', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    console.log('Parameter updated successfully:', result);
                    // Update the local data
                    if (currentTopologyData && currentTopologyData.elements) {
                        const element = currentTopologyData.elements.find(e => e.uid === elementUid);
                        if (element && element.parameters && element.parameters[parameterName]) {
                            element.parameters[parameterName].value = parseFloat(newValue);
                        }
                    }
                } else {
                    console.error('Error updating parameter:', result.error);
                    showCustomModal(
                        'Error al Actualizar Par√°metro',
                        'No se pudo actualizar el par√°metro del elemento de red.',
                        'error',
                        null,
                        {
                            details: result.error
                        }
                    );
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showCustomModal(
                    'Error de Comunicaci√≥n',
                    'Ocurri√≥ un error de comunicaci√≥n al intentar actualizar el par√°metro.',
                    'error',
                    null,
                    {
                        details: error.message || error.toString()
                    }
                );
            });
        }

        function highlightSelectedNodes() {
            // Reset all markers to default
            for (const key in markers) {
                if (Object.prototype.hasOwnProperty.call(markers, key)) {
                    if (!key.startsWith('Edfa')) {
                         markers[key].setIcon(defaultNodeIcon);
                    }
                }
            }

            const sourceId = document.getElementById('source-node').value;
            const destinationId = document.getElementById('destination-node').value;

            const sourceIcon = {
                url: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png',
                scaledSize: new google.maps.Size(32, 32)
            };

            const destinationIcon = {
                url: 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png',
                scaledSize: new google.maps.Size(32, 32)
            };

            if (sourceId && markers[sourceId]) {
                markers[sourceId].setIcon(sourceIcon);
            }

            if (destinationId && markers[destinationId]) {
                if (destinationId === sourceId) {
                    // Maybe a different icon if source and destination are the same
                    markers[destinationId].setIcon({
                        url: 'http://maps.google.com/mapfiles/ms/icons/purple-dot.png',
                        scaledSize: new google.maps.Size(32, 32)
                    });
                } else {
                    markers[destinationId].setIcon(destinationIcon);
                }
            }
        }

        function adjustMapHeight() {
            const panel = document.querySelector('#main-content-section .calculation-panel');
            const mapContainerEl = document.getElementById('map-container');
            if (panel && mapContainerEl) {
                mapContainerEl.style.height = panel.offsetHeight + 'px';
            }
        }

        // Initial adjustment (after slight delay to allow layout)
        setTimeout(adjustMapHeight, 100);
        window.addEventListener('resize', adjustMapHeight);

        // Validation for number of routes input
        document.addEventListener('DOMContentLoaded', function() {
            const numberOfRoutesInput = document.getElementById('number-of-routes');
            
            numberOfRoutesInput.addEventListener('input', function() {
                let value = parseInt(this.value);
                
                // If field is empty, allow it to remain empty
                if (this.value === '') {
                    return;
                }
                
                // If value is not a number or less than 1, set to 1
                if (isNaN(value) || value < 1) {
                    this.value = 1;
                } else if (value > 10) {
                    this.value = 10;
                }
            });
            
            // Prevent entering non-numeric characters
            numberOfRoutesInput.addEventListener('keypress', function(e) {
                // Allow backspace, delete, tab, escape, enter
                if ([8, 9, 27, 13, 46].indexOf(e.keyCode) !== -1 ||
                    // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
                    (e.keyCode === 65 && e.ctrlKey === true) ||
                    (e.keyCode === 67 && e.ctrlKey === true) ||
                    (e.keyCode === 86 && e.ctrlKey === true) ||
                    (e.keyCode === 88 && e.ctrlKey === true)) {
                    return;
                }
                // Ensure that it is a number and stop the keypress
                if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
                    e.preventDefault();
                }
            });
        });

        // Parse optical parameter values with proper unit conversion
        function parseOpticalParameter(parameterName, value) {
            const numValue = parseFloat(value);
            
            if (isNaN(numValue)) {
                console.warn(`Invalid numeric value for ${parameterName}: ${value}`);
                return 0;
            }
            
            // Convert from display units to base units (Hz) for frequency parameters
            switch (parameterName) {
                case 'f_min':
                case 'f_max':
                    // Input assumed to be in THz, convert to Hz
                    if (value.toString().includes('e')) {
                        return parseFloat(value); // Already in scientific notation (Hz)
                    }
                    return numValue * 1e12; // Convert THz to Hz
                    
                case 'spacing':
                    // Input assumed to be in GHz, convert to Hz  
                    if (value.toString().includes('e')) {
                        return parseFloat(value); // Already in scientific notation (Hz)
                    }
                    return numValue * 1e9; // Convert GHz to Hz
                    
                case 'baud_rate':
                    // Input assumed to be in Gbaud, convert to Hz
                    if (value.toString().includes('e')) {
                        return parseFloat(value); // Already in scientific notation (Hz)
                    }
                    return numValue * 1e9; // Convert Gbaud to Hz
                    
                case 'roll_off':
                case 'tx_osnr':
                case 'sys_margins':
                case 'power_dbm':
                case 'tx_power_dbm':
                default:
                    // These parameters don't need unit conversion
                    return numValue;
            }
        }

        // Validate calculate button state
        function validateCalculateButton() {
            const sourceNode = document.getElementById('source-node').value;
            const destinationNode = document.getElementById('destination-node').value;
            const numberOfRoutes = document.getElementById('number-of-routes').value;
            const criteriaSelected = document.querySelector('input[name="criteria"]:checked');
            const button = document.getElementById('calculate-route-button');
            
            // Enable button only if all required fields are filled
            const isValid = sourceNode && destinationNode && numberOfRoutes && 
                           sourceNode !== destinationNode && 
                           parseInt(numberOfRoutes) > 0 && 
                           criteriaSelected;
            
            button.disabled = !isValid;
            
            // Add visual feedback
            if (isValid) {
                button.classList.remove('btn-secondary');
                button.classList.add('btn-primary');
                button.title = 'Calcular rutas √≥ptimas';
            } else {
                button.classList.remove('btn-primary');
                button.classList.add('btn-secondary');
                let errorMsg = 'Complete los campos requeridos: ';
                let errors = [];
                if (!sourceNode) errors.push('Nodo origen');
                if (!destinationNode) errors.push('Nodo destino');
                if (!numberOfRoutes || parseInt(numberOfRoutes) <= 0) errors.push('N√∫mero de rutas');
                if (sourceNode && destinationNode && sourceNode === destinationNode) errors.push('Nodos origen y destino deben ser diferentes');
                if (!criteriaSelected) errors.push('Criterio de c√°lculo');
                button.title = errorMsg + errors.join(', ');
            }
        }

        // Route calculation function
        function calculateRoutes() {
            const sourceNode = document.getElementById('source-node').value;
            const destinationNode = document.getElementById('destination-node').value;
            const numberOfRoutes = parseInt(document.getElementById('number-of-routes').value);
            const calculationCriteria = document.querySelector('input[name="criteria"]:checked').value;
            const currentTopology = document.getElementById('topology-select').value;
            
            // Validate inputs
            if (!sourceNode || !destinationNode || !numberOfRoutes || !currentTopology) {
                let missingFields = [];
                if (!sourceNode) missingFields.push('Nodo origen');
                if (!destinationNode) missingFields.push('Nodo destino');
                if (!numberOfRoutes) missingFields.push('N√∫mero de rutas');
                if (!currentTopology) missingFields.push('Topolog√≠a seleccionada');
                
                showCustomModal(
                    'Campos Requeridos Incompletos',
                    'Para calcular las rutas, debe completar todos los campos obligatorios.',
                    'warning',
                    null,
                    {
                        validation_errors: missingFields.map(field => `${field} es requerido`)
                    }
                );
                return;
            }
            
            if (sourceNode === destinationNode) {
                showCustomModal(
                    'Nodos Inv√°lidos',
                    'El nodo origen y el nodo destino deben ser diferentes para calcular una ruta.',
                    'warning'
                );
                return;
            }
            
            // Get optical parameters with proper unit conversion
            const opticalParams = {
                f_min: parseOpticalParameter('f_min', document.getElementById('f-min').value),
                f_max: parseOpticalParameter('f_max', document.getElementById('f-max').value),
                spacing: parseOpticalParameter('spacing', document.getElementById('spacing').value),
                baud_rate: parseOpticalParameter('baud_rate', document.getElementById('baud-rate').value),
                roll_off: parseOpticalParameter('roll_off', document.getElementById('roll-off').value),
                tx_osnr: parseOpticalParameter('tx_osnr', document.getElementById('tx-osnr').value),
                sys_margins: parseOpticalParameter('sys_margins', document.getElementById('sys-margins').value),
                power_dbm: parseOpticalParameter('power_dbm', document.getElementById('power-dbm').value)
            };
            
            // Debug: Log the parsed parameters
            console.log('Parsed optical parameters:', opticalParams);
            
            // Prepare request data
            const requestData = {
                topology_filename: currentTopology,
                source_node: sourceNode,
                destination_node: destinationNode,
                number_of_routes: numberOfRoutes,
                calculation_criteria: calculationCriteria,
                optical_parameters: opticalParams
            };
            
            // Show loading state
            const button = document.getElementById('calculate-route-button');
            const originalText = button.textContent;
            button.textContent = 'Calculando...';
            button.disabled = true;
            
            // Clear previous results
            clearRouteResults();
            
            // Send request
            fetch('/calculate_routes', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                button.textContent = originalText;
                button.disabled = false;
                
                if (data.success) {
                    displayRouteResults(data);
                    
                    // Show validation warnings if present (calculations succeeded but recommendations exist)
                    if (data.validation_warnings) {
                        let additionalData = {
                            validation_errors: data.validation_warnings.warnings || []
                        };
                        
                        // Include console messages if available
                        if (data.console_messages && data.console_messages.length > 0) {
                            additionalData.console_messages = data.console_messages;
                        }
                        
                        showCustomModal(
                            'C√°lculo Exitoso con Recomendaciones',
                            'Si los c√°lculos no se completaron correctamente , evalue las observaciones en la topolog√≠a.',
                            'info',
                            data.validation_warnings.documentation_url,
                            additionalData
                        );
                    } else if (data.console_messages && data.console_messages.length > 0) {
                        // Show console messages even if no validation warnings
                        showCustomModal(
                            'Informaci√≥n del Proceso de C√°lculo',
                            'Si los calculos no se completaron correctamente, evalue las inconsistencias en la topolog√≠a.',
                            'info',
                            'https://guiatopologias.netlify.app/',
                            {
                                console_messages: data.console_messages
                            }
                        );
                    }
                } else {
                    // Handle different types of errors with appropriate messaging
                    let title = 'Error en el C√°lculo de Rutas';
                    let message = data.error || 'Ocurri√≥ un error desconocido durante el c√°lculo.';
                    let documentationUrl = data.documentation_url || null;
                    let additionalData = {};
                    
                    // Add validation message if provided
                    if (data.validation_message) {
                        message = data.validation_message;
                    }
                    
                    // Add validation errors if provided
                    if (data.validation_errors && data.validation_errors.length > 0) {
                        additionalData.validation_errors = data.validation_errors;
                    }
                    
                    // Add technical details if provided
                    if (data.details) {
                        additionalData.details = data.details;
                    }
                    
                    // Add console messages if provided
                    if (data.console_messages && data.console_messages.length > 0) {
                        additionalData.console_messages = data.console_messages;
                    }
                    
                    // Determine error type for appropriate styling
                    let errorType = 'error';
                    if (data.error_type === 'topology_error' || data.validation_errors) {
                        errorType = 'warning';
                        title = 'Error de Validaci√≥n de Topolog√≠a';
                    }
                    
                    showCustomModal(title, message, errorType, documentationUrl, additionalData);
                }
            })
            .catch(error => {
                button.textContent = originalText;
                button.disabled = false;
                console.error('Error:', error);
                showCustomModal(
                    'Error de Comunicaci√≥n',
                    'No se pudo establecer comunicaci√≥n con el servidor para procesar el c√°lculo de rutas.',
                    'error',
                    'https://guiatopologias.netlify.app/',
                    {
                        details: error.message || error.toString(),
                        console_messages: ['Error de red: No se pudo conectar con el servidor']
                    }
                );
            });
        }

        // Clear previous route results
        function clearRouteResults() {
            // Only clear route highlight polylines, not topology connections
            polylines.forEach(line => {
                if (line.routeHighlight) {
                    line.setMap(null);
                }
            });
            polylines = polylines.filter(line => !line.routeHighlight);
            
            // Clear results display
            const resultsContainer = document.getElementById('route-results');
            if (resultsContainer) {
                resultsContainer.innerHTML = '';
            }
        }

        // Display route calculation results
        function displayRouteResults(data) {
            // Create or get results container
            let resultsContainer = document.getElementById('route-results');
            if (!resultsContainer) {
                resultsContainer = document.createElement('div');
                resultsContainer.id = 'route-results';
                resultsContainer.style.marginTop = '20px';
                document.getElementById('calculation-section').appendChild(resultsContainer);
            }
            
            // Build results HTML with professional table formatting
            let html = `
                <div class="calculation-panel">
                    <div class="d-flex justify-content-between align-items-center mb-4">
                        <h3 class="panel-title mb-0">Resultados del C√°lculo de Rutas</h3>
                        <span class="badge bg-primary">${data.routes.length} ruta${data.routes.length > 1 ? 's' : ''} encontrada${data.routes.length > 1 ? 's' : ''}</span>
                    </div>
                    
                    <!-- PAR√ÅMETROS DEL CANAL √ìPTICO -->
                    <div class="mb-4">
                        <h5 class="text-primary mb-3">Par√°metros del Canal √ìptico</h5>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead class="table-dark">
                                    <tr>
                                        <th scope="col">Par√°metro</th>
                                        <th scope="col">Valor</th>
                                        <th scope="col">Unidad</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>f_min</strong></td>
                                        <td>${(data.optical_parameters.f_min / 1e12).toFixed(2)}</td>
                                        <td>THz</td>
                                    </tr>
                                    <tr>
                                        <td><strong>f_max</strong></td>
                                        <td>${(data.optical_parameters.f_max / 1e12).toFixed(2)}</td>
                                        <td>THz</td>
                                    </tr>
                                    <tr>
                                        <td><strong>spacing</strong></td>
                                        <td>${(data.optical_parameters.spacing / 1e9).toFixed(2)}</td>
                                        <td>GHz</td>
                                    </tr>
                                    <tr>
                                        <td><strong>num_channels</strong></td>
                                        <td>${data.optical_parameters.num_channels}</td>
                                        <td>-</td>
                                    </tr>
                                    <tr>
                                        <td><strong>baud_rate</strong></td>
                                        <td>${(data.optical_parameters.baud_rate / 1e9).toFixed(2)}</td>
                                        <td>Gbaud</td>
                                    </tr>
                                    <tr>
                                        <td><strong>roll_off</strong></td>
                                        <td>${data.optical_parameters.roll_off}</td>
                                        <td>-</td>
                                    </tr>
                                    <tr>
                                        <td><strong>tx_osnr</strong></td>
                                        <td>${data.optical_parameters.tx_osnr}</td>
                                        <td>dB</td>
                                    </tr>
                                    <tr>
                                        <td><strong>sys_margins</strong></td>
                                        <td>${data.optical_parameters.sys_margins}</td>
                                        <td>dB</td>
                                    </tr>
                                    <tr>
                                        <td><strong>power_dbm</strong></td>
                                        <td>${data.optical_parameters.power_dbm}</td>
                                        <td>dBm</td>
                                    </tr>
                                     
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Transceivers Summary -->
                    <div class="row mb-4">
                        <div class="col-md-6">
                            <h5 class="text-success mb-3">Transceivers Disponibles</h5>
                            <div class="table-responsive">
                                <table class="table table-sm table-bordered">
                                    <thead class="table-success">
                                        <tr>
                                            <th scope="col">#</th>
                                            <th scope="col">Transceiver ID</th>
                                        </tr>
                                    </thead>
                                    <tbody>
            `;
            
            data.transceivers_disponibles.forEach((tx, index) => {
                const isSource = tx === data.source_uid;
                const rowClass = isSource ? 'table-warning' : '';
                const badge = isSource ? '<span class="badge bg-warning text-dark ms-2">Origen</span>' : '';
                html += `
                    <tr class="${rowClass}">
                        <td>${index + 1}</td>
                        <td>${tx}${badge}</td>
                    </tr>
                `;
            });
            
            html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <div class="col-md-6">
                            <h5 class="text-info mb-3">Transceivers Destino Disponibles</h5>
                            <div class="table-responsive">
                                <table class="table table-sm table-bordered">
                                    <thead class="table-info">
                                        <tr>
                                            <th scope="col">#</th>
                                            <th scope="col">Transceiver ID</th>
                                        </tr>
                                    </thead>
                                    <tbody>
            `;
            
            data.transceivers_destino_disponibles.forEach((tx, index) => {
                const isDestination = tx === data.destination_uid;
                const rowClass = isDestination ? 'table-primary' : '';
                const badge = isDestination ? '<span class="badge bg-primary ms-2">Destino</span>' : '';
                html += `
                    <tr class="${rowClass}">
                        <td>${index + 1}</td>
                        <td>${tx}${badge}</td>
                    </tr>
                `;
            });
            
            html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Search Summary -->
                    <div class="alert alert-info mb-4">
                        <h6 class="alert-heading">Resumen de B√∫squeda</h6>
                        <p class="mb-2">Se buscaron hasta <strong>${data.num_routes_requested}</strong> rutas entre <strong>${data.source_uid}</strong> ‚Üí <strong>${data.destination_uid}</strong></p>
                        <p class="mb-0"><strong>Criterio de optimizaci√≥n:</strong> ${data.calculation_criteria === 'osnr' ? 'OSNR (mejor calidad de se√±al)' : 'Distancia (ruta m√°s corta)'}</p>
                    </div>
            `;
            
            // Add each route with enhanced styling - avoid red/danger colors to prevent confusion with topology
            data.routes.forEach((route, index) => {
                const routeColors = ['primary', 'success', 'info', 'secondary', 'dark', 'primary'];
                const routeColor = routeColors[index % routeColors.length];
                
                html += `
                    <div class="route-result mb-4 border border-${routeColor} rounded shadow-sm">
                        <div class="card-header bg-${routeColor} text-white">
                            <h5 class="mb-0">Ruta ${route.ruta_num} ${data.calculation_criteria === 'osnr' ? '(Optimizada por OSNR)' : '(Optimizada por Distancia)'}</h5>
                        </div>
                        <div class="card-body">
                            
                            <!-- Tabla de nodos -->
                            <div class="mb-4">
                                <h6 class="text-secondary mb-3">Tabla de Nodos en la Ruta</h6>
                                <div class="table-responsive">
                                    <table class="table table-striped table-hover">
                                        <thead class="table-secondary">
                                            <tr>
                                                <th scope="col">√çndice</th>
                                                <th scope="col">UID</th>
                                                <th scope="col">Tipo</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                `;
                
                route.ruta_nodos.forEach(nodo => {
                    let nodeClass = '';
                    let typeBadgeClass = '';
                    switch(nodo.tipo) {
                        case 'TX/RX':
                            nodeClass = 'fw-bold';
                            typeBadgeClass = 'bg-primary';
                            break;
                        case 'Roadm':
                            nodeClass = '';
                            typeBadgeClass = 'bg-success';
                            break;
                        case 'Fiber':
                            nodeClass = '';
                            typeBadgeClass = 'bg-info';
                            break;
                        case 'EDFA':
                            nodeClass = '';
                            typeBadgeClass = 'bg-warning text-dark';
                            break;
                        default:
                            nodeClass = '';
                            typeBadgeClass = 'bg-secondary';
                    }
                    
                    html += `
                        <tr>
                            <td><span class="badge bg-light text-dark">${nodo.idx}</span></td>
                            <td class="${nodeClass}">${nodo.uid}</td>
                            <td><span class="badge ${typeBadgeClass}">${nodo.tipo}</span></td>
                        </tr>
                    `;
                });
                
                html += `
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            
                            <!-- Detalles de fibras -->
                            <div class="mb-4">
                                <h6 class="text-secondary mb-3">Detalles de Fibras</h6>
                `;
                
                if (route.fibras.length > 0) {
                    html += `
                        <div class="table-responsive">
                            <table class="table table-sm table-bordered">
                                <thead class="table-light">
                                    <tr>
                                        <th scope="col">Fibra UID</th>
                                        <th scope="col">Longitud (km)</th>
                                    </tr>
                                </thead>
                                <tbody>
                    `;
                    
                    route.fibras.forEach(fibra => {
                        html += `
                            <tr>
                                <td class="font-monospace">${fibra.uid}</td>
                                <td class="text-end"><strong>${fibra.length_km.toFixed(2)}</strong> km</td>
                            </tr>
                        `;
                    });
                    
                    html += `
                                </tbody>
                            </table>
                        </div>
                    `;
                } else {
                    html += '<p class="text-muted">No se encontraron detalles de fibras para esta ruta.</p>';
                }
                
                html += `
                            </div>
                            
                            <!-- Receptor final -->
                            <div class="mb-4">
                                <h6 class="text-secondary mb-3">
                                    M√©tricas del Receptor Final
                                    ${data.calculation_criteria === 'osnr' ? '<span class="badge bg-success ms-2">Optimizada por OSNR</span>' : ''}
                                </h6>
                                <div class="alert alert-light">
                                    <h6 class="alert-heading">Receptor: ${route.receptor_uid}</h6>
                                    <div class="row">
                                        <div class="col-md-6">
                                            <div class="table-responsive">
                                                <table class="table table-sm">
                                                    <tbody>
                                                        <tr>
                                                            <td><strong>GSNR (0.1nm)</strong></td>
                                                            <td class="text-end"><span class="badge ${data.calculation_criteria === 'osnr' ? 'bg-success' : 'bg-primary'}">${route.snr_01nm.toFixed(2)} dB</span></td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>GSNR (signal bw)</strong></td>
                                                            <td class="text-end"><span class="badge ${data.calculation_criteria === 'osnr' ? 'bg-success' : 'bg-primary'}">${route.snr_bw ? route.snr_bw.toFixed(2) + ' dB' : 'N/A'}</span></td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <div class="table-responsive">
                                                <table class="table table-sm">
                                                    <tbody>
                                                        <tr>
                                                            <td><strong>OSNR(0.1nm)</strong></td>
                                                            <td class="text-end"><span class="badge ${data.calculation_criteria === 'osnr' ? 'bg-success' : 'bg-secondary'}">${route.osnr_01nm.toFixed(2)} dB</span></td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>OSNR(signal bw)</strong></td>
                                                            <td class="text-end"><span class="badge ${data.calculation_criteria === 'osnr' ? 'bg-success' : 'bg-secondary'}">${route.osnr_bw ? route.osnr_bw.toFixed(2) + ' dB' : 'N/A'}</span></td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Distancia total y acciones -->
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h6 class="text-secondary mb-2">
                                        Distancia Total
                                        ${data.calculation_criteria === 'distance' ? '<span class="badge bg-warning text-dark ms-2">Optimizada</span>' : ''}
                                    </h6>
                                    <span class="badge ${data.calculation_criteria === 'distance' ? 'bg-warning text-dark' : 'bg-info'} fs-6">${route.distancia_total_km.toFixed(2)} km</span>
                                </div>
                                <div>
                                    <button class="btn btn-outline-${routeColor} btn-sm" onclick="highlightRoute(${index})">
                                        Resaltar en Mapa
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `
                    <div class="mt-4 text-center">
                        <button class="btn btn-warning" onclick="clearAllRouteHighlights()">
                            Limpiar Todas las Rutas Resaltadas
                        </button>
                    </div>
                </div>
            `;
            resultsContainer.innerHTML = html;
            
            // Store routes data for highlighting
            window.calculatedRoutes = data.routes;
        }

        // Highlight a specific route on the map
        function highlightRoute(routeIndex) {
            if (!window.calculatedRoutes || !window.calculatedRoutes[routeIndex]) {
                return;
            }
            
            // Clear existing route highlights only
            polylines.forEach(line => {
                if (line.routeHighlight) {
                    line.setMap(null);
                }
            });
            polylines = polylines.filter(line => !line.routeHighlight);
            
            const route = window.calculatedRoutes[routeIndex];
            const uid_path = route.uid_path;
            
            // Draw route path with distinctive styling - colors avoid red range to prevent confusion with topology links
            const routeColors = ['#0066CC', '#28A745', '#7209B7', '#17A2B8', '#6F42C1', '#20C997', '#0D6EFD', '#198754', '#6610F2', '#0DCAF0'];
            const routeColor = routeColors[routeIndex % routeColors.length];
            
            for (let i = 0; i < uid_path.length - 1; i++) {
                const startUid = uid_path[i];
                const endUid = uid_path[i + 1];
                
                // Find nodes in the current topology
                const startNode = findNodeByUid(startUid);
                const endNode = findNodeByUid(endUid);
                
                if (startNode && endNode) {
                    const routeLine = new google.maps.Polyline({
                        path: [
                            { lat: startNode.latitude, lng: startNode.longitude },
                            { lat: endNode.latitude, lng: endNode.longitude }
                        ],
                        geodesic: true,
                        strokeColor: routeColor,
                        strokeOpacity: 1.0,
                        strokeWeight: 6,
                        map: map,
                        zIndex: 1000 // Ensure route highlights appear above topology connections
                    });
                    
                    routeLine.routeHighlight = true;
                    polylines.push(routeLine);
                }
            }
            
            // Scroll to map container to show the highlighted route
            scrollToMap();
        }

        // Scroll to map container with smooth animation
        function scrollToMap() {
            const mapContainer = document.getElementById('map-container');
            if (mapContainer) {
                mapContainer.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });
            }
        }

        // Helper function to find node by UID
        function findNodeByUid(uid) {
            if (!currentTopologyData || !currentTopologyData.elements) {
                return null;
            }
            
            for (const element of currentTopologyData.elements) {
                if (element.uid === uid) {
                    const location = extraerUbicacion(element);
                    if (location && location.lat && location.lng) {
                        return {
                            latitude: parseFloat(location.lat),
                            longitude: parseFloat(location.lng)
                        };
                    }
                }
            }
            return null;
        }

        // Clear all route highlights from map
        function clearAllRouteHighlights() {
            polylines.forEach(line => {
                if (line.routeHighlight) {
                    line.setMap(null);
                }
            });
            polylines = polylines.filter(line => !line.routeHighlight);
        }

        // Automatically fit map bounds to show all network nodes
        function fitMapToNetwork(nodesMap) {
            const nodeValues = Object.values(nodesMap);
            
            if (nodeValues.length === 0) {
                console.log('No nodes to fit map bounds');
                return;
            }
            
            // Create bounds object
            const bounds = new google.maps.LatLngBounds();
            
            // Extend bounds to include all nodes
            nodeValues.forEach(node => {
                bounds.extend(new google.maps.LatLng(node.latitude, node.longitude));
            });
            
            // Fit map to bounds with some padding
            map.fitBounds(bounds);
            
            // Optional: Set a maximum zoom level to prevent over-zooming on small networks
            const listener = google.maps.event.addListener(map, "idle", function() {
                if (map.getZoom() > 15) {
                    map.setZoom(15);
                }
                google.maps.event.removeListener(listener);
            });
            
            console.log(`Map fitted to ${nodeValues.length} network nodes`);
        }

        // Manual function to center map to network (called by button)
        function centerMapToNetwork() {
            if (Object.keys(currentNodesMap).length > 0) {
                fitMapToNetwork(currentNodesMap);
                console.log('Map manually centered to network');
            } else {
                console.log('No network loaded to center map');
                showCustomModal(
                    'Red No Disponible',
                    'No hay una red cargada actualmente. Por favor, seleccione o suba un archivo de topolog√≠a primero.',
                    'info'
                );
            }
        }
    </script>
    
    <script
        src="https://maps.googleapis.com/maps/api/js?key={{ maps_api_key }}&callback=inicializarMapa&libraries=geometry"
        async
        defer
    ></script>
</body>
