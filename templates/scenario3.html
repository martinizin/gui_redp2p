<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topología de Red</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        /* Contenedores de diseño principal */
        body {
            padding-top: 110px; /* Espacio para navegación fija incluyendo menú */
            font-size: 0.9rem;
        }
        #navigation {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: white;
            z-index: 1000;
            padding: 8px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Contenedor de sección de carga */
        #upload-section {
            background-color: white;
            padding: 20px;
            margin: 10px auto;
            max-width: 1400px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #e0e0e0;
        }
        #upload-section h2 {
            color: #343a40;
            font-size: 1.2rem;
            margin-bottom: 8px;
            text-align: center;
            font-weight: 500;
        }
        #controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
        #controls h1 {
            font-size: 0.9rem;
            margin: 0;
            color: #495057;
            font-weight: 500;
        }
        
        /* Contenedor de sección de mapa */
        #map-section {
            padding: 0;
            margin-top: 0;
        }
        #map-container {
            height: 50vh;
            width: 100%;
            max-width: 1400px;
            min-height: 380px;
            margin: 0 auto;
            position: relative;
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            transition: border-color 0.3s ease;
            background-color: white;
        }
        
        /* Ajustes responsivos */
        @media (max-width: 768px) {
            body {
                padding-top: 90px; /* Más espacio para navegación móvil */
            }
            #upload-section {
                margin: 5px;
                padding: 15px;
            }
            #map-section {
                padding: 20px 10px;
            }
            #map-container {
                height: 60vh;
                min-height: 400px;
                border-radius: 8px;
            }
            #controls {
                flex-direction: column;
                gap: 10px;
            }
        }
        
        #map-container.active {
            border-color: #007bff;
            box-shadow: 0 8px 25px rgba(0,123,255,0.3);
        }
        #zoom-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
            z-index: 1000;
            display: none;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        #topology-select {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ced4da;
            background-color: white;
            font-size: 0.95rem;
            min-width: 200px;
        }
        #topology-select:focus {
            border-color: #80bdff;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
            outline: none;
        }
        #upload-button {
            padding: 8px 16px;
            border-radius: 5px;
            border: 1px solid #007bff;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        #upload-button:hover {
            background-color: #0056b3;
            border-color: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,123,255,0.3);
        }
        
        /* Estilos del panel de parámetros */
        #parameters-panel {
            position: fixed;
            right: -400px;
            top: 80px;
            width: 380px;
            height: calc(100vh - 100px);
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px 0 0 8px;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            transition: right 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }
        #parameters-panel.open {
            right: 0;
        }
        #parameters-panel .panel-header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #parameters-panel .panel-header h3 {
            margin: 0;
            font-size: 1.1rem;
            color: #343a40;
        }
        #parameters-panel .panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        .parameter-group {
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background: #f8f9fa;
        }
        .parameter-group-header {
            background: #007bff;
            color: white;
            padding: 8px 12px;
            font-weight: 500;
            font-size: 0.9rem;
            border-radius: 5px 5px 0 0;
        }
        .parameter-item {
            padding: 8px 12px;
            border-bottom: 1px solid #e9ecef;
            background: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .parameter-item:last-child {
            border-bottom: none;
            border-radius: 0 0 5px 5px;
        }
        .parameter-label {
            font-size: 0.85rem;
            color: #495057;
            font-weight: 500;
            flex: 1;
            cursor: help;
        }
        .parameter-value {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .parameter-input {
            width: 80px;
            padding: 4px 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 0.8rem;
            text-align: right;
        }
        .parameter-input:disabled {
            background-color: #f8f9fa;
            color: #6c757d;
        }
        .parameter-unit {
            font-size: 0.75rem;
            color: #6c757d;
            min-width: 35px;
        }
        .close-panel {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #6c757d;
        }
        .close-panel:hover {
            color: #343a40;
        }
        
        /* Estilos de tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 220px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1002;
            bottom: 125%;
            left: 50%;
            margin-left: -110px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem;
        }
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Estilos de sección de cálculo */
        #calculation-section {
            padding: 0 15px;
            max-width: 1400px;
            margin: 5px auto 5px auto; /* Further reduced margins */
            background-color: transparent;
            border-top: none;
        }
        .calculation-panel {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            border: 1px solid #e0e0e0;
            height: auto; /* Changed from 100% to auto to fit content */
            min-height: auto; /* Remove any minimum height constraints */
        }
        .panel-title {
            font-size: 1rem;
            color: #343a40;
            margin-bottom: 10px; /* Reduced from 12px to 10px */
            font-weight: 500;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px; /* Reduced from 6px to 5px */
        }
        .form-row-flex {
            display: flex;
            gap: 12px;
            margin-bottom: 6px; /* Reduced from 8px to 6px */
            align-items: flex-start;
        }
        .flex-grow {
            flex-grow: 1;
        }
        .align-self-flex-end {
            align-self: flex-end;
        }
        .sub-panel-title {
            font-size: 0.95rem;
            color: #6c757d;
            margin-top: 0;
            margin-bottom: 8px; /* Reduced from 10px to 8px */
            font-weight: 500;
        }
        .form-group {
            margin-bottom: 0.4rem; /* Reduced from 0.5rem to 0.4rem */
        }
        .form-group label {
            display: block;
            margin-bottom: .25rem;
            font-weight: 500;
            color: #495057;
            font-size: 0.85rem;
        }
        .form-control, .custom-select, .btn {
            padding: .275rem .65rem;
            font-size: 0.9rem;
            border-radius: .2rem;
        }
        .custom-select {
            height: calc(1.5em + .55rem + 2px);
        }
        #calculate-route-button {
            width: 100%;
            padding: 0.4rem 1rem;
            font-size: 0.9rem;
            font-weight: 500;
        }
        .radio-group {
            padding-top: 0.15rem; /* Reduced from 0.25rem to 0.15rem */
        }
        .form-check-label {
            font-weight: 400;
        }
        .form-check-inline {
            margin-right: 0.75rem; /* Reduced spacing between radio buttons */
        }

        /* Estilos de InfoWindow personalizado */
        .custom-infowindow {
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 0;
            max-width: 350px; /* Ancho aumentado para parámetros EDFA */
            min-width: 280px; /* Ancho mínimo */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px; /* Fuente ligeramente más grande */
            color: #333;
        }
        .custom-infowindow-header {
            font-size: 15px; /* Fuente más pequeña */
            font-weight: 600;
            color: #ffffff;
            margin: 0;
            padding: 8px 12px; /* Relleno reducido */
            background: #007bff;
            border-bottom: 1px solid #0069d9;
            border-radius: 8px 8px 0 0;
        }
        .custom-infowindow-content {
            padding: 12px; /* Relleno reducido */
        }
        .custom-infowindow-content p {
            margin: 0 0 6px 0;
            line-height: 1.5;
        }
        .custom-infowindow-content strong {
            font-weight: 600;
            color: #555;
            min-width: 80px;
            display: inline-block;
        }
        .custom-infowindow-content .param-group {
            margin-top: 5px;
            padding-left: 15px;
            border-left: 3px solid #007bff;
        }
        .custom-infowindow-content .param-group p {
            font-family: monospace;
            font-size: 13px;
            margin-bottom: 3px;
        }
        .role-source {
            color: #28a745;
            font-weight: 700;
        }
        .role-destination {
            color: #007bff;
            font-weight: 700;
        }

        /* ----- Personalización de InfoWindow de Google Maps ----- */
        /* Oculta la burbuja blanca y sombra por defecto */
        .gm-style .gm-style-iw-c {
            padding: 0 !important;
            background-color: transparent !important;
            box-shadow: none !important;
        }
        .gm-style .gm-style-iw-d {
           overflow: hidden !important; /* Oculta barras de desplazamiento */
        }
        /* Oculta el botón de cerrar por defecto */
        .gm-style .gm-style-iw-t button {
            display: none !important;
        }
        /* Oculta la flecha por defecto */
        .gm-style .gm-style-iw-t::after {
            display: none;
        }

        #navigation .h1, #navigation h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem !important;
        }
        #navigation .btn-group .btn {
            padding: .25rem .75rem;
            font-size: .875rem;
        }
        #navigation .scenario-nav {
            margin-bottom: 0 !important; /* Prevent extra space pushing content up */
        }

        /* Asegura que el mapa coincida con la altura del panel derecho */
        .col-lg-8, .col-lg-4, #map-section {
            height: 100%;
        }
        #map-container, #map {
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="navigation">
        <div class="container-fluid">
            <div class="row">
                <div class="col-12 text-center">
                    <h1 class="mb-3">Simulador de topologías de red en google maps</h1>
                    {% include 'scenario_nav.html' %}
                </div>
            </div>
        </div>
    </div>
    <!-- Upload Section Container -->
    <div id="upload-section">
        <h2>Gestión de Topologías</h2>
        <div id="controls">
            <h1>Visualización de Topología</h1>
            <select id="topology-select"></select>
            <input type="file" id="topology-upload" accept="application/json" style="display: none;" />
            <button id="upload-button">Subir Archivo</button>
        </div>
    </div>

    <!-- Main Content Section: Map and Simulation Parameters -->
    <div id="main-content-section" style="max-width: 1400px; margin: 5px auto; padding: 0 15px;">
        <div class="row">
            <!-- Map Column -->
            <div class="col-lg-8">
                <div id="map-section">
                    <div id="map-container">
                        <div id="zoom-hint">Click map to enable zoom, or hold Ctrl while scrolling</div>
                        <div id="map"></div>
                    </div>
                </div>
            </div>

            <!-- Simulation Parameters Column -->
            <div class="col-lg-4">
                <div class="calculation-panel" style="height: 100%;">
                    <h3 class="panel-title">Parámetros de Simulación</h3>
                    <div class="form-group">
                        <label for="f-min">f_min</label>
                        <input type="text" id="f-min" class="form-control" value="{{ si_config.f_min }}" placeholder="e.g., 191.3e12">
                    </div>
                    <div class="form-group">
                        <label for="baud-rate">baud_rate</label>
                        <input type="text" id="baud-rate" class="form-control" value="{{ si_config.baud_rate }}" placeholder="e.g., 32e9">
                    </div>
                    <div class="form-group">
                        <label for="f-max">f_max</label>
                        <input type="text" id="f-max" class="form-control" value="{{ si_config.f_max }}" placeholder="e.g., 195.1e12">
                    </div>
                    <div class="form-group">
                        <label for="spacing">spacing</label>
                        <input type="text" id="spacing" class="form-control" value="{{ si_config.spacing }}" placeholder="e.g., 50e9">
                    </div>
                    <div class="form-group">
                        <label for="power-dbm">power_dbm</label>
                        <input type="number" id="power-dbm" class="form-control" value="{{ si_config.power_dbm }}" step="0.1">
                    </div>
                    <div class="form-group">
                        <label for="tx-power-dbm">tx_power_dbm</label>
                        <input type="number" id="tx-power-dbm" class="form-control" value="{{ si_config.tx_power_dbm }}" step="0.1">
                    </div>
                    <div class="form-group">
                        <label for="roll-off">roll_off</label>
                        <input type="number" id="roll-off" class="form-control" value="{{ si_config.roll_off }}" step="0.01">
                    </div>
                    <div class="form-group">
                        <label for="tx-osnr">tx_osnr</label>
                        <input type="number" id="tx-osnr" class="form-control" value="{{ si_config.tx_osnr }}" step="0.1">
                    </div>
                    <div class="form-group">
                        <label for="sys-margins">sys_margins</label>
                        <input type="number" id="sys-margins" class="form-control" value="{{ si_config.sys_margins }}" step="1">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Route Calculation Section -->
    <div id="calculation-section">
        <div class="calculation-panel">
            <h3 class="panel-title">Cálculo de Ruta</h3>
            <h5 class="sub-panel-title">Selección de Nodos</h5>
            <div class="form-row-flex">
                <div class="form-group flex-grow">
                    <label for="source-node">Nodo Origen</label>
                    <select id="source-node" class="form-control custom-select"></select>
                </div>
                <div class="form-group flex-grow">
                    <label for="destination-node">Nodo Destino</label>
                    <select id="destination-node" class="form-control custom-select"></select>
                </div>
            </div>
            <div class="form-row-flex">
                <div class="form-group flex-grow">
                    <label for="number-of-routes">Ingrese el número de rutas optimas deseadas</label>
                    <input type="number" id="number-of-routes" class="form-control" 
                           min="1" max="10" step="1" 
                           placeholder="Máximo 10">
                </div>
            </div>
            <div class="form-row-flex">
                <div class="form-group">
                    <label>Criterio de Cálculo</label>
                    <div class="radio-group">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="criteria" id="criteria-distance" value="distance" checked>
                            <label class="form-check-label" for="criteria-distance">Distancia</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="criteria" id="criteria-osnr" value="osnr">
                            <label class="form-check-label" for="criteria-osnr">OSNR</label>
                        </div>
                    </div>
                </div>
                <div class="form-group align-self-flex-end">
                    <button id="calculate-route-button" class="btn btn-primary">Calcular Ruta</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Parameters Panel -->
    <div id="parameters-panel">
        <div class="panel-header">
            <h3>Network Parameters</h3>
            <button class="close-panel" onclick="closeParametersPanel()">&times;</button>
        </div>
        <div class="panel-body">
            <div id="parameters-content">
                <p style="color: #6c757d; text-align: center; padding: 20px;">
                    Click on a network element to view and modify its parameters
                </p>
            </div>
        </div>
    </div>

    <script>
        let map;
        let markers = {};
        let infoWindows = {};
        let polylines = [];
        let currentTopologyData = null;
        let defaultNodeIcon;
        
        // Función global para cerrar todas las ventanas de información y prevenir superposición
        function closeAllInfoWindows() {
            Object.values(infoWindows).forEach(iw => iw.close());
        }
        
        // Inicializa el mapa
        function inicializarMapa() {
            defaultNodeIcon = {
                url: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png',
                scaledSize: new google.maps.Size(28, 28)
            };
            
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: -1.831239, lng: -78.183406 }, // Centro de Ecuador
                zoom: 7,
                scrollwheel: false, // Inicialmente deshabilitado
                gestureHandling: 'greedy' // Permite panorámica y zoom con controles táctiles/ratón
            });

            // Implementa control de zoom explícito basado en interacción
            const mapContainer = document.getElementById('map-container');
            const zoomHint = document.getElementById('zoom-hint');
            let mapIsActive = false;
            
            // Muestra pista al pasar el ratón
            mapContainer.addEventListener('mouseenter', function() {
                if (!mapIsActive) {
                    zoomHint.style.display = 'block';
                }
            });
            
            mapContainer.addEventListener('mouseleave', function() {
                zoomHint.style.display = 'none';
                if (mapIsActive) {
                    mapIsActive = false;
                    mapContainer.classList.remove('active');
                    map.setOptions({ scrollwheel: false });
                }
            });
            
            // Habilita interacción del mapa cuando el usuario hace clic en el mapa
            mapContainer.addEventListener('mousedown', function() {
                mapIsActive = true;
                mapContainer.classList.add('active');
                zoomHint.style.display = 'none';
                map.setOptions({ scrollwheel: true });
            });
            
            // Deshabilita desplazamiento del mapa al hacer clic fuera del mapa
            document.addEventListener('click', function(e) {
                if (!mapContainer.contains(e.target)) {
                    mapIsActive = false;
                    mapContainer.classList.remove('active');
                    map.setOptions({ scrollwheel: false });
                }
            });
            
            // Maneja eventos de desplazamiento con control explícito
            mapContainer.addEventListener('wheel', function(e) {
                // Permite zoom del mapa solo si el mapa está activo O se mantiene presionada la tecla Ctrl
                if (mapIsActive || e.ctrlKey) {
                    map.setOptions({ scrollwheel: true });
                    e.preventDefault(); // Previene desplazamiento de página
                    e.stopPropagation();
                } else {
                    map.setOptions({ scrollwheel: false });
                    // Permite desplazamiento normal de página - no hace nada para dejar que el evento burbujee
                }
            }, { passive: false });

            // Carga los nombres de las topologías y llena el selector
            fetch('/get_topology_names')
                .then(response => response.json())
                .then(files => {
                    const select = document.getElementById('topology-select');
                    files.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file.replace('.json', '');
                        select.appendChild(option);
                    });

                    // Carga la topología inicial
                    if (files.length > 0) {
                        cargarTopologia(files[0]);
                    }
                });

            // Agrega el detector de eventos de cambio al selector
            document.getElementById('topology-select').addEventListener('change', (e) => {
                cargarTopologia(e.target.value);
            });

            document.getElementById('source-node').addEventListener('change', () => highlightSelectedNodes());
            document.getElementById('destination-node').addEventListener('change', () => highlightSelectedNodes());

            const uploadButton = document.getElementById('upload-button');
            const fileInput = document.getElementById('topology-upload');

            uploadButton.addEventListener('click', () => fileInput.click());

            fileInput.addEventListener('change', () => {
                const file = fileInput.files[0];
                if (!file) {
                    return;
                }

                const formData = new FormData();
                formData.append('file', file);

                fetch('/upload_topology', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.filename) {
                        // Actualiza la lista de topologías
                        fetch('/get_topology_names')
                            .then(response => response.json())
                            .then(files => {
                                const select = document.getElementById('topology-select');
                                select.innerHTML = ''; // Limpia las opciones existentes
                                files.forEach(f => {
                                    const option = document.createElement('option');
                                    option.value = f;
                                    option.textContent = f.replace('.json', '');
                                    select.appendChild(option);
                                });
                                
                                // Selecciona y carga la nueva topología
                                select.value = data.filename;
                                cargarTopologia(data.filename);
                                fileInput.value = ''; // Reinicia el input del archivo
                            });
                    } else {
                        alert('Falló la subida del archivo: ' + (data.error || 'Error desconocido'));
                    }
                })
                .catch(error => {
                    console.error('Error al subir el archivo:', error);
                    alert('Ocurrió un error durante la subida del archivo.');
                });
            });
        }

        function cargarTopologia(filename) {
            fetch(`/get_topology?filename=${encodeURIComponent(filename)}`)
                .then(response => response.json())
                .then(data => {
                    currentTopologyData = data;
                    dibujarTopologiaEnMapa(data);
                    populateTransceiverDropdowns(data);
                })
                .catch(error => console.error('Error cargando la topología:', error));
        }

        function populateTransceiverDropdowns(data) {
            const sourceSelect = document.getElementById('source-node');
            const destinationSelect = document.getElementById('destination-node');

            sourceSelect.innerHTML = '<option value="">Seleccione nodo origen</option>';
            destinationSelect.innerHTML = '<option value="">Seleccione nodo destino</option>';

            const transceivers = (data.elements || []).filter(el => el.type === 'Transceiver');

            if (transceivers.length === 0) {
                const option = '<option value="" disabled>No se encontraron transceivers</option>';
                sourceSelect.innerHTML = option;
                destinationSelect.innerHTML = option;
                return;
            }

            transceivers.forEach(t => {
                const option = document.createElement('option');
                option.value = t.uid;
                option.textContent = t.uid;
                sourceSelect.appendChild(option.cloneNode(true));
                destinationSelect.appendChild(option);
            });
        }

        function dibujarTopologiaEnMapa(data) {
            limpiarMapa();
            const nodesMap = procesarNodos(data);
            dibujarNodos(nodesMap);
            dibujarEnlaces(data, nodesMap);
        }

        function procesarNodos(data) {
            const nodesMap = {};
            const elements = data.elements || [];
            
            elements.forEach(el => {
                // Omite elementos que no son nodos de red o no tienen ubicación
                if (el.type === "Fiber" || el.type === "fibre") return;
                
                const nodeId = normalizarIdNodo(el.uid);
                const location = extraerUbicacion(el);
                
                console.log('Processing element:', el.uid, 'Type:', el.type, 'Location:', location);
                
                if (location && location.lat && location.lng) {
                    nodesMap[nodeId] = {
                        id: nodeId,
                        latitude: parseFloat(location.lat),
                        longitude: parseFloat(location.lng),
                        title: String(el.uid),
                        type: el.type,
                        city: location.city || el.metadata?.location?.city,
                        raw: el
                    };
                    console.log('Added node to map:', nodeId, 'Type:', el.type);
                }
            });
            console.log('Final nodesMap:', nodesMap);
            return nodesMap;
        }

        function extraerUbicacion(element) {
            if (element.metadata?.location) {
                return {
                    lat: element.metadata.location.latitude,
                    lng: element.metadata.location.longitude,
                    city: element.metadata.location.city
                };
            } else if (element.location) {
                return {
                    lat: element.location.latitude || element.location.lat,
                    lng: element.location.longitude || element.location.lng,
                    city: element.location.city
                };
            }
            return null;
        }

        /* Genera tooltip específico para EDFA (usando lógica de scenario02.py) */
        function crearTooltipEdfa(edfaElement) {
            console.log('Creating EDFA tooltip for element:', edfaElement);
            
            if (!edfaElement) {
                console.log('No EDFA element provided');
                return '';
            }
            
            const uid = edfaElement.uid || 'N/A';
            const type = edfaElement.type || 'Edfa';
            const typeVar = edfaElement.type_variety || 'N/A';
            
            console.log('EDFA basic info - UID:', uid, 'Type:', type, 'Type Variety:', typeVar);
            
            // gain_target desde operacional (topología)
            let gainTarget = 'N/A';
            if (edfaElement.operational && edfaElement.operational.gain_target !== undefined) {
                gainTarget = edfaElement.operational.gain_target;
                console.log('Found gain_target in operational:', gainTarget);
            } else if (edfaElement.parameters && edfaElement.parameters.gain_target) {
                gainTarget = edfaElement.parameters.gain_target.value ?? edfaElement.parameters.gain_target;
                console.log('Found gain_target in parameters:', gainTarget);
            } else {
                console.log('No gain_target found. Operational:', edfaElement.operational, 'Parameters:', edfaElement.parameters);
            }

            // NF desde configuración de equipos (como enfoque de scenario02.py)
            let nfVal = 'N/A';
            if (edfaElement.parameters && edfaElement.parameters.nf0 !== undefined) {
                nfVal = edfaElement.parameters.nf0.value ?? edfaElement.parameters.nf0;
                console.log('Found nf0 in element parameters:', nfVal);
            } else if (edfaElement.type_variety && currentTopologyData && currentTopologyData.eqpt_config) {
                // Busca en configuración de equipos (misma lógica que scenario02.py)
                const edfaConfigs = currentTopologyData.eqpt_config.Edfa || [];
                console.log('Looking for type_variety in equipment config:', edfaElement.type_variety, 'Available configs:', edfaConfigs);
                const cfg = edfaConfigs.find(c => c.type_variety === edfaElement.type_variety);
                if (cfg) {
                    nfVal = cfg.nf0 !== undefined ? cfg.nf0 : (cfg.nf_min !== undefined ? cfg.nf_min : 'N/A');
                    console.log('Found NF in equipment config:', nfVal, 'Config:', cfg);
                } else {
                    console.log('No matching equipment config found for type_variety:', edfaElement.type_variety);
                }
            } else {
                console.log('Cannot find NF - missing data. Type variety:', edfaElement.type_variety, 'Has topology data:', !!currentTopologyData, 'Has eqpt_config:', !!(currentTopologyData && currentTopologyData.eqpt_config));
            }

            const tooltipHTML = `
                <div class="custom-infowindow">
                    <h3 class="custom-infowindow-header">EDFA</h3>
                    <div class="custom-infowindow-content">
                        <p><strong>UID:</strong> ${uid}</p>
                        <p><strong>Type:</strong> ${type}</p>
                        <p><strong>Type Variety:</strong> ${typeVar}</p>
                        <p><strong>gain_target:</strong> ${gainTarget} dB</p>
                        <p><strong>NF:</strong> ${nfVal} dB</p>
                    </div>
                </div>`;
            
            console.log('Generated EDFA tooltip HTML:', tooltipHTML);
            return tooltipHTML;
        }

        function dibujarNodos(nodesMap) {
            Object.values(nodesMap).forEach(node => {
                // Elige icono basado en el tipo de elemento
                let iconMarker = defaultNodeIcon;
                if (node.raw && node.raw.type === 'Edfa') {
                    iconMarker = {
                        path: 'M -5,0 0,-8 5,0 0,8 Z',
                        scale: 1,
                        fillColor: '#FF4500',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#8B0000'
                    };
                }

                const marker = new google.maps.Marker({
                    position: { lat: node.latitude, lng: node.longitude },
                    map: map,
                    title: node.title,
                    icon: iconMarker
                });
                markers[node.id] = marker;

                // Genera contenido de tooltip (detección EDFA ahora manejada dentro de crearContenidoInfoNodo)
                let tooltipContent = crearContenidoInfoNodo(node);
                
                console.log('Node:', node.id, 'Type:', node.type, 'Raw type:', node.raw?.type);
                
                const infoWindow = new google.maps.InfoWindow({
                    content: tooltipContent
                });
                infoWindows[node.id] = infoWindow;

                marker.addListener('mouseover', () => {
                    closeAllInfoWindows();
                    
                    const sourceId = document.getElementById('source-node').value;
                    const destinationId = document.getElementById('destination-node').value;
                    let role = null;
                    if (node.id === sourceId) role = "Nodo Origen";
                    if (node.id === destinationId) role = "Nodo Destino";
                    
                    const content = crearContenidoInfoNodo(node, role);
                    infoWindow.setContent(content);
                    infoWindow.open(map, marker);
                });

                marker.addListener('mouseout', () => {
                    infoWindow.close();
                });

                // Clic deshabilitado – panel de parámetros removido según nuevos requerimientos
                marker.addListener("click", () => {});
            });
        }

        function dibujarEnlaces(data, nodesMap) {
            const elements = data.elements || [];
            const connections = data.connections || [];

            if (connections.length === 0) return;

            const elementsMap = new Map(elements.map(el => [normalizarIdNodo(el.uid), el]));
            const adj = new Map();

            connections.forEach(c => {
                const from = normalizarIdNodo(c.from_node);
                const to = normalizarIdNodo(c.to_node);
                if (!adj.has(from)) adj.set(from, new Set());
                if (!adj.has(to)) adj.set(to, new Set());
                adj.get(from).add(to);
                adj.get(to).add(from); // Tratar como no dirigido para encontrar el camino
            });

            const drawnLinks = new Set();

            for (const startNodeId of Object.keys(nodesMap)) {
                const q = [[startNodeId, [startNodeId]]];
                const visitedInSearch = new Set([startNodeId]);

                while (q.length > 0) {
                    const [currentNodeId, path] = q.shift();

                    if (!adj.has(currentNodeId)) continue;

                    for (const neighborId of adj.get(currentNodeId)) {
                        if (visitedInSearch.has(neighborId)) continue;
                        
                        if (nodesMap[neighborId]) { // Se encontró otro nodo con ubicación
                            const linkKey = [startNodeId, neighborId].sort().join('->');
                            if (drawnLinks.has(linkKey)) continue;
                            
                            visitedInSearch.add(neighborId);
                            const newPath = [...path, neighborId];
                            
                            const startNode = nodesMap[startNodeId];
                            const endNode = nodesMap[neighborId];

                            let totalLength = 0;
                            let hasFiber = false;
                            let fiberElement = null;

                            for (const nodeId of newPath) {
                                const element = elementsMap.get(nodeId);
                                if (element && (element.type === 'Fiber' || element.type === 'fibre')) {
                                    hasFiber = true;
                                    fiberElement = element; // Store fiber element for tooltip
                                    if (element.params && element.params.length) {
                                        totalLength += element.params.length;
                                    }
                                }
                            }

                            dibujarConexion(startNode, endNode, { color: "#FF0000", weight: 3 }, fiberElement);
                            drawnLinks.add(linkKey);

                            // Removed automatic EDFA insertion along fibers
                        } else {
                            visitedInSearch.add(neighborId);
                            const newPath = [...path, neighborId];
                            q.push([neighborId, newPath]);
                        }
                    }
                }
            }
        }

        function dibujarConexion(startNode, endNode, style, fiberElement = null) {
            const path = [
                { lat: startNode.latitude, lng: startNode.longitude },
                { lat: endNode.latitude, lng: endNode.longitude }
            ];

            const line = new google.maps.Polyline({
                path: path,
                geodesic: true,
                strokeColor: style.color || "#FF0000",
                strokeOpacity: style.opacity || 1.0,
                strokeWeight: style.weight || 2,
                map: map
            });
            polylines.push(line);

            const distance = haversine(
                startNode.latitude, startNode.longitude,
                endNode.latitude, endNode.longitude
            );

            const infoWindow = new google.maps.InfoWindow({
                content: crearContenidoInfoEnlace(style, startNode, endNode, distance, fiberElement)
            });

            line.addListener('mouseover', (event) => {
                closeAllInfoWindows();
                
                infoWindow.setPosition(event.latLng);
                infoWindow.open(map);
            });
            line.addListener('mouseout', () => {
                infoWindow.close();
            });
        }
        
        function limpiarMapa() {
            Object.values(markers).forEach(marker => marker.setMap(null));
            polylines.forEach(line => line.setMap(null));
            Object.values(infoWindows).forEach(iw => iw.close());
            markers = {};
            polylines = [];
            infoWindows = {};
        }
        
        function obtenerPuntoMedio(p1, p2) {
            return {
                lat: (p1.lat + p2.lat) / 2,
                lng: (p1.lng + p2.lng) / 2
            };
        }

        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radio de la Tierra en km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            return 2 * R * Math.asin(Math.sqrt(a));
        }

        function crearContenidoInfoNodo(node, role = null) {
            // Check if this is an EDFA element
            const isEdfa = (node.raw && node.raw.type === 'Edfa') || node.type === 'Edfa';
            
            if (isEdfa) {
                // Use EDFA-specific tooltip
                return crearTooltipEdfa(node.raw || node);
            }
            
            // Default tooltip for non-EDFA elements
            let roleHtml = '';
            if (role) {
                const roleClass = role === 'Nodo Origen' ? 'role-source' : 'role-destination';
                roleHtml = `<p><strong>Rol:</strong> <span class="${roleClass}">${role}</span></p>`;
            }

            let content = `
                <div class="custom-infowindow">
                    <h3 class="custom-infowindow-header">${node.title}</h3>
                    <div class="custom-infowindow-content">
                        ${roleHtml}
                        <p><strong>Ciudad:</strong> ${node.city || 'N/A'}</p>
                        <p><strong>Tipo:</strong> ${node.type}</p>
                        <p><strong>Latitud:</strong> ${node.latitude.toFixed(4)}°</p>
                        <p><strong>Longitud:</strong> ${node.longitude.toFixed(4)}°</p>
                    </div>
                </div>`;
            return content;
        }

        function crearContenidoInfoEnlace(linkData, startNode, endNode, distance, fiberElement = null) {
            let fiberParamsHtml = '';
            
            // Add fiber parameters if available
            if (fiberElement && fiberElement.params) {
                const params = fiberElement.params;
                fiberParamsHtml = `
                    <hr style="margin: 8px 0;">
                    <p><strong>Parámetros de Fibra:</strong></p>
                    <p><strong>loss_coef:</strong> ${params.loss_coef || 'N/A'} dB/km</p>
                    <p><strong>att_in:</strong> ${params.att_in || 'N/A'} dB</p>
                    <p><strong>con_in:</strong> ${params.con_in || 'N/A'} dB</p>
                    <p><strong>con_out:</strong> ${params.con_out || 'N/A'} dB</p>
                `;
            }
            
            return `
                <div class="custom-infowindow">
                    <h3 class="custom-infowindow-header">Enlace de Fibra</h3>
                    <div class="custom-infowindow-content">
                        <p><strong>Desde:</strong> ${startNode.title}</p>
                        <p><strong>Hasta:</strong> ${endNode.title}</p>
                        <p><strong>Distancia:</strong> ${distance.toFixed(2)} km</p>
                        ${fiberParamsHtml}
                    </div>
                </div>`;
        }

        function normalizarIdNodo(id) {
            return String(id).trim();
        }

        // Parameters Panel Functions
        function openParametersPanel() {
            document.getElementById('parameters-panel').classList.add('open');
        }

        function closeParametersPanel() {
            document.getElementById('parameters-panel').classList.remove('open');
        }

        function showElementParameters(element) {
            openParametersPanel();
            const parametersContent = document.getElementById('parameters-content');
            
            if (!element.parameters) {
                parametersContent.innerHTML = '<p style="color: #dc3545; text-align: center; padding: 20px;">No parameters available for this element</p>';
                return;
            }

            let html = `<div class="parameter-group">
                <div class="parameter-group-header">${element.type}: ${element.uid}</div>`;
            
            for (const [paramName, paramData] of Object.entries(element.parameters)) {
                const inputId = `param-${element.uid}-${paramName}`;
                const isEditable = paramData.editable;
                
                html += `<div class="parameter-item">
                    <div class="parameter-label tooltip">
                        ${paramName.replace(/_/g, ' ').toUpperCase()}
                        <span class="tooltiptext">${paramData.tooltip}</span>
                    </div>
                    <div class="parameter-value">
                        <input type="number" 
                               id="${inputId}" 
                               class="parameter-input" 
                               value="${paramData.value}" 
                               step="0.1" 
                               ${!isEditable ? 'disabled' : ''}
                               ${isEditable ? `onchange="updateParameter('${element.uid}', '${paramName}', this.value)"` : ''}>
                        <span class="parameter-unit">${paramData.unit}</span>
                    </div>
                </div>`;
            }
            
            html += '</div>';
            parametersContent.innerHTML = html;
        }

        function updateParameter(elementUid, parameterName, newValue) {
            const data = {
                element_uid: elementUid,
                parameter_name: parameterName,
                new_value: parseFloat(newValue)
            };

            fetch('/update_network_parameters', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    console.log('Parameter updated successfully:', result);
                    // Update the local data
                    if (currentTopologyData && currentTopologyData.elements) {
                        const element = currentTopologyData.elements.find(e => e.uid === elementUid);
                        if (element && element.parameters && element.parameters[parameterName]) {
                            element.parameters[parameterName].value = parseFloat(newValue);
                        }
                    }
                } else {
                    console.error('Error updating parameter:', result.error);
                    alert('Error updating parameter: ' + result.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error updating parameter');
            });
        }

        function highlightSelectedNodes() {
            // Reset all markers to default
            for (const key in markers) {
                if (Object.prototype.hasOwnProperty.call(markers, key)) {
                    if (!key.startsWith('Edfa')) {
                         markers[key].setIcon(defaultNodeIcon);
                    }
                }
            }

            const sourceId = document.getElementById('source-node').value;
            const destinationId = document.getElementById('destination-node').value;

            const sourceIcon = {
                url: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png',
                scaledSize: new google.maps.Size(32, 32)
            };

            const destinationIcon = {
                url: 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png',
                scaledSize: new google.maps.Size(32, 32)
            };

            if (sourceId && markers[sourceId]) {
                markers[sourceId].setIcon(sourceIcon);
            }

            if (destinationId && markers[destinationId]) {
                if (destinationId === sourceId) {
                    // Maybe a different icon if source and destination are the same
                    markers[destinationId].setIcon({
                        url: 'http://maps.google.com/mapfiles/ms/icons/purple-dot.png',
                        scaledSize: new google.maps.Size(32, 32)
                    });
                } else {
                    markers[destinationId].setIcon(destinationIcon);
                }
            }
        }

        function adjustMapHeight() {
            const panel = document.querySelector('#main-content-section .calculation-panel');
            const mapContainerEl = document.getElementById('map-container');
            if (panel && mapContainerEl) {
                mapContainerEl.style.height = panel.offsetHeight + 'px';
            }
        }

        // Initial adjustment (after slight delay to allow layout)
        setTimeout(adjustMapHeight, 100);
        window.addEventListener('resize', adjustMapHeight);

        // Validation for number of routes input
        document.addEventListener('DOMContentLoaded', function() {
            const numberOfRoutesInput = document.getElementById('number-of-routes');
            
            numberOfRoutesInput.addEventListener('input', function() {
                let value = parseInt(this.value);
                
                // If field is empty, allow it to remain empty
                if (this.value === '') {
                    return;
                }
                
                // If value is not a number or less than 1, set to 1
                if (isNaN(value) || value < 1) {
                    this.value = 1;
                } else if (value > 10) {
                    this.value = 10;
                }
            });
            
            // Prevent entering non-numeric characters
            numberOfRoutesInput.addEventListener('keypress', function(e) {
                // Allow backspace, delete, tab, escape, enter
                if ([8, 9, 27, 13, 46].indexOf(e.keyCode) !== -1 ||
                    // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
                    (e.keyCode === 65 && e.ctrlKey === true) ||
                    (e.keyCode === 67 && e.ctrlKey === true) ||
                    (e.keyCode === 86 && e.ctrlKey === true) ||
                    (e.keyCode === 88 && e.ctrlKey === true)) {
                    return;
                }
                // Ensure that it is a number and stop the keypress
                if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
                    e.preventDefault();
                }
            });
        });
    </script>
    
    <script
        src="https://maps.googleapis.com/maps/api/js?key={{ maps_api_key }}&callback=inicializarMapa&libraries=geometry"
        async
        defer
    ></script>
</body>
